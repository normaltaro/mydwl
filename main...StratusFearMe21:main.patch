From 6b785ee303e0df40da90cc4ec5910ce9830d355a Mon Sep 17 00:00:00 2001
From: Isaac Mills <rooster0055@protonmail.com>
Date: Wed, 8 Jun 2022 21:36:05 -0400
Subject: [PATCH 1/2] For patching

---
 Makefile     |    8 +-
 commands.c   |  541 +++++++++++++++++++++++
 commands.h   |  307 +++++++++++++
 config.def.h |    6 +-
 config.mk    |    1 +
 dwl.c        | 1204 +++++++++++++++++++++++++++++++++++++++++++++++++-
 hmm.log      |   24 +
 list.c       |  159 +++++++
 list.h       |   35 ++
 stringop.c   |  331 ++++++++++++++
 stringop.h   |   30 ++
 11 files changed, 2634 insertions(+), 12 deletions(-)
 create mode 100644 commands.c
 create mode 100644 commands.h
 create mode 100644 hmm.log
 create mode 100644 list.c
 create mode 100644 list.h
 create mode 100644 stringop.c
 create mode 100644 stringop.h

diff --git a/Makefile b/Makefile
index 59b2519b..f3a478f4 100644
--- a/Makefile
+++ b/Makefile
@@ -11,7 +11,7 @@ WAYLAND_PROTOCOLS = `pkg-config --variable=pkgdatadir wayland-protocols`
 WAYLAND_SCANNER   = `pkg-config --variable=wayland_scanner wayland-scanner`
 
 # CFLAGS / LDFLAGS
-PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
+PKGS      = wlroots wayland-server xkbcommon libinput json-c $(XLIBS)
 DWLCFLAGS = `pkg-config --cflags $(PKGS)` $(DWLCPPFLAGS) $(CFLAGS) $(XWAYLAND)
 LDLIBS    = `pkg-config --libs $(PKGS)`
 
@@ -21,10 +21,12 @@ LDLIBS    = `pkg-config --libs $(PKGS)`
 # protocols, which are specified in XML. wlroots requires you to rig these up
 # to your build system yourself and provide them in the include path.
 all: dwl
-dwl: dwl.o util.o
-	$(CC) $(LDLIBS) $(LDFLAGS) -o $@ dwl.o util.o
+dwl: dwl.o util.o list.o stringop.o
+	$(CC) $(LDLIBS) $(LDFLAGS) -o $@ dwl.o util.o list.o stringop.o
 dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
 util.o: util.c util.h
+list.o: list.c list.h
+stringop.o: stringop.c stringop.h
 
 # wayland scanner rules to generate .h / .c files
 xdg-shell-protocol.h:
diff --git a/commands.c b/commands.c
new file mode 100644
index 00000000..a25e386d
--- /dev/null
+++ b/commands.c
@@ -0,0 +1,541 @@
+#include "commands.h"
+
+// Returns error object, or NULL if check succeeds.
+struct cmd_results *checkarg(int argc, const char *name, enum expected_args type, int val) {
+	const char *error_name = NULL;
+	switch (type) {
+	case EXPECTED_AT_LEAST:
+		if (argc < val) {
+			error_name = "at least ";
+		}
+		break;
+	case EXPECTED_AT_MOST:
+		if (argc > val) {
+			error_name = "at most ";
+		}
+		break;
+	case EXPECTED_EQUAL_TO:
+		if (argc != val) {
+			error_name = "";
+		}
+	}
+	return error_name ?
+		cmd_results_new(CMD_INVALID, "Invalid %s command "
+				"(expected %s%d argument%s, got %d)",
+				name, error_name, val, val != 1 ? "s" : "", argc)
+		: NULL;
+}
+
+/* Keep alphabetized */
+static const struct cmd_handler handlers[] = {
+	{ "assign", NULL },
+	{ "bar", NULL },
+	{ "bindcode", NULL },
+	{ "bindgesture", NULL },
+	{ "bindswitch", NULL },
+	{ "bindsym", NULL },
+	{ "client.background", NULL },
+	{ "client.focused", NULL },
+	{ "client.focused_inactive", NULL },
+	{ "client.focused_tab_title", NULL },
+	{ "client.placeholder", NULL },
+	{ "client.unfocused", NULL },
+	{ "client.urgent", NULL },
+	{ "default_border", NULL },
+	{ "default_floating_border", NULL },
+	{ "exec", NULL },
+	{ "exec_always", NULL },
+	{ "floating_maximum_size", NULL },
+	{ "floating_minimum_size", NULL },
+	{ "floating_modifier", NULL },
+	{ "focus", NULL },
+	{ "focus_follows_mouse", NULL },
+	{ "focus_on_window_activation", NULL },
+	{ "focus_wrapping", NULL },
+	{ "font", NULL },
+	{ "for_window", NULL },
+	{ "force_display_urgency_hint", NULL },
+	{ "force_focus_wrapping", NULL },
+	{ "fullscreen", NULL },
+	{ "gaps", NULL },
+	{ "hide_edge_borders", NULL },
+	{ "input", NULL },
+	{ "mode", NULL },
+	{ "mouse_warping", NULL },
+	{ "new_float", NULL },
+	{ "new_window", NULL },
+	{ "no_focus", NULL },
+	{ "output", NULL },
+	{ "popup_during_fullscreen", NULL },
+	{ "seat", NULL },
+	{ "set", NULL },
+	{ "show_marks", NULL },
+	{ "smart_borders", NULL },
+	{ "smart_gaps", NULL },
+	{ "tiling_drag", NULL },
+	{ "tiling_drag_threshold", NULL },
+	{ "title_align", NULL },
+	{ "titlebar_border_thickness", NULL },
+	{ "titlebar_padding", NULL },
+	{ "unbindcode", NULL },
+	{ "unbindgesture", NULL },
+	{ "unbindswitch", NULL },
+	{ "unbindsym", NULL },
+	{ "workspace", cmd_workspace },
+	{ "workspace_auto_back_and_forth", NULL },
+};
+
+/* Runtime-only commands. Keep alphabetized */
+static const struct cmd_handler command_handlers[] = {
+	{ "border", NULL },
+	{ "create_output", NULL },
+	{ "exit", NULL },
+	{ "floating", NULL },
+	{ "fullscreen", NULL },
+	{ "inhibit_idle", NULL },
+	{ "kill", NULL },
+	{ "layout", NULL },
+	{ "mark", NULL },
+	{ "max_render_time", NULL },
+	{ "move", NULL },
+	{ "nop", NULL },
+	{ "opacity", NULL },
+	{ "reload", NULL },
+	{ "rename", NULL },
+	{ "resize", NULL },
+	{ "scratchpad", NULL },
+	{ "shortcuts_inhibitor", NULL },
+	{ "split", NULL },
+	{ "splith", NULL },
+	{ "splitt", NULL },
+	{ "splitv", NULL },
+	{ "sticky", NULL },
+	{ "swap", NULL },
+	{ "title_format", NULL },
+	{ "unmark", NULL },
+	{ "urgent", NULL },
+};
+
+static int handler_compare(const void *_a, const void *_b) {
+	const struct cmd_handler *a = _a;
+	const struct cmd_handler *b = _b;
+	return strcasecmp(a->command, b->command);
+}
+
+const struct cmd_handler *find_handler(char *line,
+		const struct cmd_handler *handlers, size_t handlers_size) {
+	const struct cmd_handler query = { .command = line };
+	if (!handlers || !handlers_size) {
+		return NULL;
+	}
+	return bsearch(&query, handlers,
+			handlers_size / sizeof(struct cmd_handler),
+			sizeof(struct cmd_handler), handler_compare);
+}
+
+static const struct cmd_handler *find_handler_ex(char *line,
+		// const struct cmd_handler *command_handlers, size_t command_handlers_size,
+		const struct cmd_handler *handlers, size_t handlers_size) {
+	/*
+	const struct cmd_handler *handler = NULL;
+		handler = find_handler(line, command_handlers, command_handlers_size);
+	return handler ? handler : find_handler(line, handlers, handlers_size);
+	*/
+	return find_handler(line, handlers, handlers_size);
+}
+
+static const struct cmd_handler *find_core_handler(char *line) {
+	return find_handler_ex(line, 
+			//command_handlers, sizeof(command_handlers),
+			handlers, sizeof(handlers)
+	);
+}
+
+char *do_var_replacement(char *str) {
+	int i;
+	char *find = str;
+	while ((find = strchr(find, '$'))) {
+		// Skip if escaped.
+		if (find > str && find[-1] == '\\') {
+			if (find == str + 1 || !(find > str + 1 && find[-2] == '\\')) {
+				++find;
+				continue;
+			}
+		}
+		// Unescape double $ and move on
+		if (find[1] == '$') {
+			size_t length = strlen(find + 1);
+			memmove(find, find + 1, length);
+			find[length] = '\0';
+			++find;
+			continue;
+		}
+		// Find matching variable
+		/*
+		for (i = 0; i < config->symbols->length; ++i) {
+			struct sway_variable *var = config->symbols->items[i];
+			int vnlen = strlen(var->name);
+			if (strncmp(find, var->name, vnlen) == 0) {
+				int vvlen = strlen(var->value);
+				char *newstr = malloc(strlen(str) - vnlen + vvlen + 1);
+				if (!newstr) {
+					fprintf(stderr,
+						"Unable to allocate replacement "
+						"during variable expansion");
+					break;
+				}
+				char *newptr = newstr;
+				int offset = find - str;
+				strncpy(newptr, str, offset);
+				newptr += offset;
+				strncpy(newptr, var->value, vvlen);
+				newptr += vvlen;
+				strcpy(newptr, find + vnlen);
+				free(str);
+				str = newstr;
+				find = str + offset + vvlen;
+				break;
+			}
+		}
+		if (i == config->symbols->length) {
+			++find;
+		}
+		*/
+	}
+	return str;
+}
+
+list_t *execute_command(char *_exec, Client *con) {
+	char *cmd;
+	char *error;
+	char matched_delim = ';';
+	list_t *containers = NULL;
+	bool using_criteria = false;
+
+	char *exec = strdup(_exec);
+	char *head = exec;
+	list_t *res_list = create_list();
+	struct criteria *criteria;
+
+	int i;
+	int argc;
+	char **argv;
+	const struct cmd_handler *handler;
+	struct cmd_results *fail_res;
+	struct sway_container *container;
+
+	struct cmd_results *res;
+	if (!res_list || !exec) {
+		return NULL;
+	}
+
+	do {
+		for (; isspace(*head); ++head) {}
+		// Extract criteria (valid for this command list only).
+		/*
+		if (matched_delim == ';') {
+			using_criteria = false;
+			if (*head == '[') {
+				error = NULL;
+				criteria = criteria_parse(head, &error);
+				if (!criteria) {
+					list_add(res_list,
+							cmd_results_new(CMD_INVALID, "%s", error));
+					free(error);
+					goto cleanup;
+				}
+				list_free(containers);
+				containers = criteria_get_containers(criteria);
+				head += strlen(criteria->raw);
+				criteria_destroy(criteria);
+				using_criteria = true;
+				// Skip leading whitespace
+				for (; isspace(*head); ++head) {}
+			}
+		}
+		*/
+		// Split command list
+		cmd = argsep(&head, ";,", &matched_delim);
+		for (; isspace(*cmd); ++cmd) {}
+
+		if (strcmp(cmd, "") == 0) {
+			fprintf(stderr, "Ignoring empty command.");
+			continue;
+		}
+		fprintf(stderr, "Handling command '%s'", cmd);
+		//TODO better handling of argv
+		argv = split_args(cmd, &argc);
+		if (strcmp(argv[0], "exec") != 0 &&
+				strcmp(argv[0], "exec_always") != 0 &&
+				strcmp(argv[0], "mode") != 0) {
+			for (i = 1; i < argc; ++i) {
+				if (*argv[i] == '\"' || *argv[i] == '\'') {
+					strip_quotes(argv[i]);
+				}
+			}
+		}
+		handler = find_core_handler(argv[0]);
+		if (!handler) {
+			list_add(res_list, cmd_results_new(CMD_INVALID,
+					"Unknown/invalid command '%s'", argv[0]));
+			free_argv(argc, argv);
+			goto cleanup;
+		}
+
+		// Var replacement, for all but first argument of set
+		for (i = 1; i < argc; ++i) {
+			argv[i] = do_var_replacement(argv[i]);
+		}
+
+
+		/*
+		if (!using_criteria) {
+			if (con) {
+				set_config_node(&con->node, true);
+			} else {
+				set_config_node(seat_get_focus_inactive(seat, &root->node),
+						false);
+			}
+			res = handler->handle(argc-1, argv+1);
+			list_add(res_list, res);
+			if (res->status == CMD_INVALID) {
+				free_argv(argc, argv);
+				goto cleanup;
+			}
+		} else if (containers->length == 0) {
+			list_add(res_list,
+					cmd_results_new(CMD_FAILURE, "No matching node."));
+		} else {
+		*/
+			fail_res = NULL;
+			res = handler->handle(argc-1, argv+1);
+			if (res->status == CMD_SUCCESS) {
+				free_cmd_results(res);
+			} else {
+				// last failure will take precedence
+				if (fail_res) {
+					free_cmd_results(fail_res);
+				}
+				fail_res = res;
+				if (res->status == CMD_INVALID) {
+					list_add(res_list, fail_res);
+					free_argv(argc, argv);
+					goto cleanup;
+				}
+			}
+			list_add(res_list,
+					fail_res ? fail_res : cmd_results_new(CMD_SUCCESS, NULL));
+		//}
+		free_argv(argc, argv);
+	} while(head);
+cleanup:
+	free(exec);
+	list_free(containers);
+	return res_list;
+}
+
+// this is like execute_command above, except:
+// 1) it ignores empty commands (empty lines)
+// 2) it does variable substitution
+// 3) it doesn't split commands (because the multiple commands are supposed to
+//	  be chained together)
+// 4) execute_command handles all state internally while config_command has
+// some state handled outside (notably the block mode, in read_config)
+struct cmd_results *config_command(char *exec, char **new_block) {
+	struct cmd_results *results = NULL;
+	int argc, i;
+	char **argv = split_args(exec, &argc);
+	char *temp;
+	const struct cmd_handler *handler;
+	const char *error;
+	char *command;
+
+	// Check for empty lines
+	if (!argc) {
+		results = cmd_results_new(CMD_SUCCESS, NULL);
+		goto cleanup;
+	}
+
+	// Check for the start of a block
+	if (argc > 1 && strcmp(argv[argc - 1], "{") == 0) {
+		*new_block = join_args(argv, argc - 1);
+		results = cmd_results_new(CMD_BLOCK, NULL);
+		goto cleanup;
+	}
+
+	// Check for the end of a block
+	if (strcmp(argv[argc - 1], "}") == 0) {
+		results = cmd_results_new(CMD_BLOCK_END, NULL);
+		goto cleanup;
+	}
+
+	// Make sure the command is not stored in a variable
+	if (*argv[0] == '$') {
+		argv[0] = do_var_replacement(argv[0]);
+		temp = join_args(argv, argc);
+		free_argv(argc, argv);
+		argv = split_args(temp, &argc);
+		free(temp);
+		if (!argc) {
+			results = cmd_results_new(CMD_SUCCESS, NULL);
+			goto cleanup;
+		}
+	}
+
+	// Determine the command handler
+	fprintf(stderr, "Config command: %s", exec);
+	handler = find_core_handler(argv[0]);
+	if (!handler || !handler->handle) {
+		error = handler
+			? "Command '%s' is shimmed, but unimplemented"
+			: "Unknown/invalid command '%s'";
+		results = cmd_results_new(CMD_INVALID, error, argv[0]);
+		goto cleanup;
+	}
+
+	/*
+	// Do variable replacement
+	if (handler->handle == cmd_set && argc > 1 && *argv[1] == '$') {
+		// Escape the variable name so it does not get replaced by one shorter
+		char *temp = calloc(1, strlen(argv[1]) + 2);
+		temp[0] = '$';
+		strcpy(&temp[1], argv[1]);
+		free(argv[1]);
+		argv[1] = temp;
+	}
+	*/
+	command = do_var_replacement(join_args(argv, argc));
+	// fprintf(stderr, "After replacement: %s", command);
+	free_argv(argc, argv);
+	argv = split_args(command, &argc);
+	free(command);
+
+	// Strip quotes and unescape the string
+	for (i = 1; i < argc; ++i) {
+		/*
+		if (handler->handle != cmd_exec && handler->handle != cmd_exec_always
+				&& handler->handle != cmd_mode
+				&& handler->handle != cmd_bindsym
+				&& handler->handle != cmd_bindcode
+				&& handler->handle != cmd_bindswitch
+				&& handler->handle != cmd_bindgesture
+				&& handler->handle != cmd_set
+				&& handler->handle != cmd_for_window
+				&& (*argv[i] == '\"' || *argv[i] == '\'')) {
+				*/
+			strip_quotes(argv[i]);
+		//}
+		unescape_string(argv[i]);
+	}
+
+	// Run command
+	results = handler->handle(argc - 1, argv + 1);
+
+cleanup:
+	free_argv(argc, argv);
+	return results;
+}
+
+struct cmd_results *config_subcommand(char **argv, int argc,
+		const struct cmd_handler *handlers, size_t handlers_size) {
+	char *command = join_args(argv, argc);
+
+	const struct cmd_handler *handler = find_handler(argv[0], handlers,
+			handlers_size);
+	fprintf(stderr, "Subcommand: %s", command);
+	free(command);
+	if (!handler) {
+		return cmd_results_new(CMD_INVALID,
+				"Unknown/invalid command '%s'", argv[0]);
+	}
+	if (handler->handle) {
+		return handler->handle(argc - 1, argv + 1);
+	}
+	return cmd_results_new(CMD_INVALID,
+			"The command '%s' is shimmed, but unimplemented", argv[0]);
+}
+
+struct cmd_results *config_commands_command(char *exec) {
+	struct cmd_results *results = NULL;
+	int argc;
+	char **argv = split_args(exec, &argc);
+	char *cmd = argv[0];
+	const struct cmd_handler *handler;
+	if (!argc) {
+		results = cmd_results_new(CMD_SUCCESS, NULL);
+		goto cleanup;
+	}
+
+	// Find handler for the command this is setting a policy for
+
+	if (strcmp(cmd, "}") == 0) {
+		results = cmd_results_new(CMD_BLOCK_END, NULL);
+		goto cleanup;
+	}
+
+	handler = find_handler(cmd, NULL, 0);
+	if (!handler && strcmp(cmd, "*") != 0) {
+		results = cmd_results_new(CMD_INVALID,
+			"Unknown/invalid command '%s'", cmd);
+		goto cleanup;
+	}
+
+	results = cmd_results_new(CMD_SUCCESS, NULL);
+
+cleanup:
+	free_argv(argc, argv);
+	return results;
+}
+
+struct cmd_results *cmd_results_new(enum cmd_status status,
+		const char *format, ...) {
+	struct cmd_results *results = malloc(sizeof(struct cmd_results));
+	if (!results) {
+		fprintf(stderr, "Unable to allocate command results");
+		return NULL;
+	}
+	results->status = status;
+	if (format) {
+		char *error = malloc(256);
+		va_list args;
+		va_start(args, format);
+		if (error) {
+			vsnprintf(error, 256, format, args);
+		}
+		va_end(args);
+		results->error = error;
+	} else {
+		results->error = NULL;
+	}
+	return results;
+}
+
+void free_cmd_results(struct cmd_results *results) {
+	if (results->error) {
+		free(results->error);
+	}
+	free(results);
+}
+
+char *cmd_results_to_json(list_t *res_list) {
+	const char *json;
+	char *res;
+	json_object *result_array = json_object_new_array();
+	for (int i = 0; i < res_list->length; ++i) {
+		struct cmd_results *results = res_list->items[i];
+		json_object *root = json_object_new_object();
+		json_object_object_add(root, "success",
+				json_object_new_boolean(results->status == CMD_SUCCESS));
+		if (results->error) {
+			json_object_object_add(root, "parse_error",
+					json_object_new_boolean(results->status == CMD_INVALID));
+			json_object_object_add(
+					root, "error", json_object_new_string(results->error));
+		}
+		json_object_array_add(result_array, root);
+	}
+	json = json_object_to_json_string(result_array);
+	res = strdup(json);
+	json_object_put(result_array);
+	return res;
+}
diff --git a/commands.h b/commands.h
new file mode 100644
index 00000000..112c9d9d
--- /dev/null
+++ b/commands.h
@@ -0,0 +1,307 @@
+#include <wlr/util/edges.h>
+
+typedef struct cmd_results *sway_cmd(int argc, char **argv);
+
+struct cmd_handler {
+	char *command;
+	sway_cmd *handle;
+};
+
+/**
+ * Indicates the result of a command's execution.
+ */
+enum cmd_status {
+	CMD_SUCCESS, 		/**< The command was successful */
+	CMD_FAILURE,		/**< The command resulted in an error */
+	CMD_INVALID, 		/**< Unknown command or parser error */
+	CMD_DEFER,		/**< Command execution deferred */
+	CMD_BLOCK,
+	CMD_BLOCK_COMMANDS,
+	CMD_BLOCK_END
+};
+
+/**
+ * Stores the result of executing a command.
+ */
+struct cmd_results {
+	enum cmd_status status;
+	/**
+	 * Human friendly error message, or NULL on success
+	 */
+	char *error;
+};
+
+enum expected_args {
+	EXPECTED_AT_LEAST,
+	EXPECTED_AT_MOST,
+	EXPECTED_EQUAL_TO
+};
+
+struct cmd_results *checkarg(int argc, const char *name,
+		enum expected_args type, int val);
+
+const struct cmd_handler *find_handler(char *line,
+		const struct cmd_handler *cmd_handlers, size_t handlers_size);
+
+/**
+ * Parse and executes a command.
+ *
+ * If the command string contains criteria then the command will be executed on
+ * all matching containers. Otherwise, it'll run on the `con` container. If
+ * `con` is NULL then it'll run on the currently focused container.
+ */
+list_t *execute_command(char *command, Client *c);
+/**
+ * Parse and handles a command during config file loading.
+ *
+ * Do not use this under normal conditions.
+ */
+struct cmd_results *config_command(char *command, char **new_block);
+/**
+ * Parse and handle a sub command
+ */
+struct cmd_results *config_subcommand(char **argv, int argc,
+		const struct cmd_handler *handlers, size_t handlers_size);
+/*
+ * Parses a command policy rule.
+ */
+struct cmd_results *config_commands_command(char *exec);
+/**
+ * Allocates a cmd_results object.
+ */
+struct cmd_results *cmd_results_new(enum cmd_status status, const char *error, ...);
+/**
+ * Frees a cmd_results object.
+ */
+void free_cmd_results(struct cmd_results *results);
+/**
+ * Serializes a list of cmd_results to a JSON string.
+ *
+ * Free the JSON string later on.
+ */
+char *cmd_results_to_json(list_t *res_list);
+
+/**
+ * TODO: Move this function and its dependent functions to container.c.
+ */
+void container_resize_tiled(Client *parent, uint32_t axis,
+		int amount);
+
+void container_find_resize_parent(Client *c,
+		uint32_t edge);
+
+/**
+ * Handlers shared by exec and exec_always.
+ */
+/*
+sway_cmd cmd_exec_validate;
+sway_cmd cmd_exec_process;
+
+sway_cmd cmd_assign;
+sway_cmd cmd_bar;
+sway_cmd cmd_bindcode;
+sway_cmd cmd_bindgesture;
+sway_cmd cmd_bindswitch;
+sway_cmd cmd_bindsym;
+sway_cmd cmd_border;
+sway_cmd cmd_client_noop;
+sway_cmd cmd_client_focused;
+sway_cmd cmd_client_focused_inactive;
+sway_cmd cmd_client_focused_tab_title;
+sway_cmd cmd_client_unfocused;
+sway_cmd cmd_client_urgent;
+sway_cmd cmd_client_placeholder;
+sway_cmd cmd_client_background;
+sway_cmd cmd_commands;
+sway_cmd cmd_create_output;
+sway_cmd cmd_default_border;
+sway_cmd cmd_default_floating_border;
+sway_cmd cmd_default_orientation;
+sway_cmd cmd_exec;
+sway_cmd cmd_exec_always;
+sway_cmd cmd_exit;
+sway_cmd cmd_floating;
+sway_cmd cmd_floating_maximum_size;
+sway_cmd cmd_floating_minimum_size;
+sway_cmd cmd_floating_modifier;
+sway_cmd cmd_floating_scroll;
+sway_cmd cmd_focus;
+sway_cmd cmd_focus_follows_mouse;
+sway_cmd cmd_focus_on_window_activation;
+sway_cmd cmd_focus_wrapping;
+sway_cmd cmd_font;
+sway_cmd cmd_for_window;
+sway_cmd cmd_force_display_urgency_hint;
+sway_cmd cmd_force_focus_wrapping;
+sway_cmd cmd_fullscreen;
+sway_cmd cmd_gaps;
+sway_cmd cmd_hide_edge_borders;
+sway_cmd cmd_include;
+sway_cmd cmd_inhibit_idle;
+sway_cmd cmd_input;
+sway_cmd cmd_seat;
+sway_cmd cmd_ipc;
+sway_cmd cmd_kill;
+sway_cmd cmd_layout;
+sway_cmd cmd_log_colors;
+sway_cmd cmd_mark;
+sway_cmd cmd_max_render_time;
+sway_cmd cmd_mode;
+sway_cmd cmd_mouse_warping;
+sway_cmd cmd_move;
+sway_cmd cmd_new_float;
+sway_cmd cmd_new_window;
+sway_cmd cmd_nop;
+sway_cmd cmd_opacity;
+sway_cmd cmd_new_float;
+sway_cmd cmd_new_window;
+sway_cmd cmd_no_focus;
+sway_cmd cmd_output;
+sway_cmd cmd_permit;
+sway_cmd cmd_popup_during_fullscreen;
+sway_cmd cmd_reject;
+sway_cmd cmd_reload;
+sway_cmd cmd_rename;
+sway_cmd cmd_resize;
+sway_cmd cmd_scratchpad;
+sway_cmd cmd_seamless_mouse;
+sway_cmd cmd_set;
+sway_cmd cmd_shortcuts_inhibitor;
+sway_cmd cmd_show_marks;
+sway_cmd cmd_smart_borders;
+sway_cmd cmd_smart_gaps;
+sway_cmd cmd_split;
+sway_cmd cmd_splith;
+sway_cmd cmd_splitt;
+sway_cmd cmd_splitv;
+sway_cmd cmd_sticky;
+sway_cmd cmd_swaybg_command;
+sway_cmd cmd_swaynag_command;
+sway_cmd cmd_swap;
+sway_cmd cmd_tiling_drag;
+sway_cmd cmd_tiling_drag_threshold;
+sway_cmd cmd_title_align;
+sway_cmd cmd_title_format;
+sway_cmd cmd_titlebar_border_thickness;
+sway_cmd cmd_titlebar_padding;
+sway_cmd cmd_unbindcode;
+sway_cmd cmd_unbindswitch;
+sway_cmd cmd_unbindgesture;
+sway_cmd cmd_unbindsym;
+sway_cmd cmd_unmark;
+sway_cmd cmd_urgent;
+*/
+sway_cmd cmd_workspace;
+/*
+sway_cmd cmd_workspace_layout;
+sway_cmd cmd_ws_auto_back_and_forth;
+sway_cmd cmd_xwayland;
+
+sway_cmd bar_cmd_bindcode;
+sway_cmd bar_cmd_binding_mode_indicator;
+sway_cmd bar_cmd_bindsym;
+sway_cmd bar_cmd_colors;
+sway_cmd bar_cmd_font;
+sway_cmd bar_cmd_gaps;
+sway_cmd bar_cmd_mode;
+sway_cmd bar_cmd_modifier;
+sway_cmd bar_cmd_output;
+sway_cmd bar_cmd_height;
+sway_cmd bar_cmd_hidden_state;
+sway_cmd bar_cmd_icon_theme;
+sway_cmd bar_cmd_id;
+sway_cmd bar_cmd_position;
+sway_cmd bar_cmd_separator_symbol;
+sway_cmd bar_cmd_status_command;
+sway_cmd bar_cmd_status_edge_padding;
+sway_cmd bar_cmd_status_padding;
+sway_cmd bar_cmd_pango_markup;
+sway_cmd bar_cmd_strip_workspace_numbers;
+sway_cmd bar_cmd_strip_workspace_name;
+sway_cmd bar_cmd_swaybar_command;
+sway_cmd bar_cmd_tray_bindcode;
+sway_cmd bar_cmd_tray_bindsym;
+sway_cmd bar_cmd_tray_output;
+sway_cmd bar_cmd_tray_padding;
+sway_cmd bar_cmd_unbindcode;
+sway_cmd bar_cmd_unbindsym;
+sway_cmd bar_cmd_wrap_scroll;
+sway_cmd bar_cmd_workspace_buttons;
+sway_cmd bar_cmd_workspace_min_width;
+
+sway_cmd bar_colors_cmd_active_workspace;
+sway_cmd bar_colors_cmd_background;
+sway_cmd bar_colors_cmd_focused_background;
+sway_cmd bar_colors_cmd_binding_mode;
+sway_cmd bar_colors_cmd_focused_workspace;
+sway_cmd bar_colors_cmd_inactive_workspace;
+sway_cmd bar_colors_cmd_separator;
+sway_cmd bar_colors_cmd_focused_separator;
+sway_cmd bar_colors_cmd_statusline;
+sway_cmd bar_colors_cmd_focused_statusline;
+sway_cmd bar_colors_cmd_urgent_workspace;
+
+sway_cmd input_cmd_seat;
+sway_cmd input_cmd_accel_profile;
+sway_cmd input_cmd_calibration_matrix;
+sway_cmd input_cmd_click_method;
+sway_cmd input_cmd_drag;
+sway_cmd input_cmd_drag_lock;
+sway_cmd input_cmd_dwt;
+sway_cmd input_cmd_events;
+sway_cmd input_cmd_left_handed;
+sway_cmd input_cmd_map_from_region;
+sway_cmd input_cmd_map_to_output;
+sway_cmd input_cmd_map_to_region;
+sway_cmd input_cmd_middle_emulation;
+sway_cmd input_cmd_natural_scroll;
+sway_cmd input_cmd_pointer_accel;
+sway_cmd input_cmd_scroll_factor;
+sway_cmd input_cmd_repeat_delay;
+sway_cmd input_cmd_repeat_rate;
+sway_cmd input_cmd_scroll_button;
+sway_cmd input_cmd_scroll_method;
+sway_cmd input_cmd_tap;
+sway_cmd input_cmd_tap_button_map;
+sway_cmd input_cmd_tool_mode;
+sway_cmd input_cmd_xkb_capslock;
+sway_cmd input_cmd_xkb_file;
+sway_cmd input_cmd_xkb_layout;
+sway_cmd input_cmd_xkb_model;
+sway_cmd input_cmd_xkb_numlock;
+sway_cmd input_cmd_xkb_options;
+sway_cmd input_cmd_xkb_rules;
+sway_cmd input_cmd_xkb_switch_layout;
+sway_cmd input_cmd_xkb_variant;
+
+sway_cmd output_cmd_adaptive_sync;
+sway_cmd output_cmd_background;
+sway_cmd output_cmd_disable;
+sway_cmd output_cmd_dpms;
+sway_cmd output_cmd_enable;
+sway_cmd output_cmd_max_render_time;
+sway_cmd output_cmd_mode;
+sway_cmd output_cmd_modeline;
+sway_cmd output_cmd_position;
+sway_cmd output_cmd_render_bit_depth;
+sway_cmd output_cmd_scale;
+sway_cmd output_cmd_scale_filter;
+sway_cmd output_cmd_subpixel;
+sway_cmd output_cmd_toggle;
+sway_cmd output_cmd_transform;
+
+sway_cmd seat_cmd_attach;
+sway_cmd seat_cmd_cursor;
+sway_cmd seat_cmd_fallback;
+sway_cmd seat_cmd_hide_cursor;
+sway_cmd seat_cmd_idle_inhibit;
+sway_cmd seat_cmd_idle_wake;
+sway_cmd seat_cmd_keyboard_grouping;
+sway_cmd seat_cmd_pointer_constraint;
+sway_cmd seat_cmd_shortcuts_inhibitor;
+sway_cmd seat_cmd_xcursor_theme;
+
+sway_cmd cmd_ipc_cmd;
+sway_cmd cmd_ipc_events;
+sway_cmd cmd_ipc_event_cmd;
+*/
diff --git a/config.def.h b/config.def.h
index 4f131dda..9621e679 100644
--- a/config.def.h
+++ b/config.def.h
@@ -78,8 +78,8 @@ static const double accel_speed = 0.0;
 /* If you want to use the windows key change this to WLR_MODIFIER_LOGO */
 #define MODKEY WLR_MODIFIER_ALT
 #define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
+	{ MODKEY,                    KEY,            view,            {.ui = TAG} }, \
+	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = TAG} }, \
 	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
 	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
 
@@ -110,7 +110,7 @@ static const Key keys[] = {
 	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
 	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
+	{ MODKEY,                    XKB_KEY_0,          viewall,        {0} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
 	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
 	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
diff --git a/config.mk b/config.mk
index ba24bb80..330b564d 100644
--- a/config.mk
+++ b/config.mk
@@ -6,6 +6,7 @@ PREFIX = /usr/local
 MANDIR = $(PREFIX)/share/man
 
 # Compile flags that can be used
+CFLAGS = -Ofast -march=native -flto
 #CFLAGS = -pedantic -Wall -Wextra -Werror -Wno-unused-parameter -Wno-sign-compare -Wno-unused-function -Wno-unused-variable -Wno-unused-result -Wdeclaration-after-statement
 
 XWAYLAND =
diff --git a/dwl.c b/dwl.c
index e4bed14c..210d4050 100644
--- a/dwl.c
+++ b/dwl.c
@@ -9,8 +9,15 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/wait.h>
+#include <sys/un.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
 #include <time.h>
+#include <ctype.h>
+#include <strings.h>
 #include <unistd.h>
+#include <json.h>
 #include <wayland-server-core.h>
 #include <wlr/backend.h>
 #include <wlr/backend/libinput.h>
@@ -54,6 +61,8 @@
 #endif
 
 #include "util.h"
+#include "list.h"
+#include "stringop.h"
 
 /* macros */
 #define MAX(A, B)               ((A) > (B) ? (A) : (B))
@@ -201,7 +210,83 @@ typedef struct {
 	int monitor;
 } Rule;
 
+#define event_mask(ev) (1 << (ev & 0x7F))
+
+enum ipc_command_type {
+	// i3 command types - see i3's I3_REPLY_TYPE constants
+	IPC_COMMAND = 0,
+	IPC_GET_WORKSPACES = 1,
+	IPC_SUBSCRIBE = 2,
+	IPC_GET_OUTPUTS = 3,
+	IPC_GET_TREE = 4,
+	IPC_GET_MARKS = 5,
+	IPC_GET_BAR_CONFIG = 6,
+	IPC_GET_VERSION = 7,
+	IPC_GET_BINDING_MODES = 8,
+	IPC_GET_CONFIG = 9,
+	IPC_SEND_TICK = 10,
+	IPC_SYNC = 11,
+	IPC_GET_BINDING_STATE = 12,
+
+	// sway-specific command types
+	IPC_GET_INPUTS = 100,
+	IPC_GET_SEATS = 101,
+
+	// Events sent from sway to clients. Events have the highest bits set.
+	IPC_EVENT_WORKSPACE = (int)((1u<<31) | 0),
+	IPC_EVENT_OUTPUT = (int)((1u<<31) | 1),
+	IPC_EVENT_MODE = (int)((1u<<31) | 2),
+	IPC_EVENT_WINDOW = (int)((1u<<31) | 3),
+	IPC_EVENT_BARCONFIG_UPDATE = (int)((1u<<31) | 4),
+	IPC_EVENT_BINDING = (int)((1u<<31) | 5),
+	IPC_EVENT_SHUTDOWN = (int)((1u<<31) | 6),
+	IPC_EVENT_TICK = (int)((1u<<31) | 7),
+
+	// sway-specific event types
+	IPC_EVENT_BAR_STATE_UPDATE = (int)((1u<<31) | 20),
+	IPC_EVENT_INPUT = (int)((1u<<31) | 21),
+};
+
+enum node_type { N_ROOT, N_OUTPUT, N_WORKSPACE, N_CONTAINER };
+
+static int ipc_socket = -1;
+static struct wl_event_source *ipc_event_source =  NULL;
+static struct sockaddr_un *ipc_sockaddr = NULL;
+static list_t *ipc_client_list = NULL;
+static ssize_t i3_tag = 0;
+static struct wl_listener ipc_display_destroy;
+
+static const char ipc_magic[] = {'i', '3', '-', 'i', 'p', 'c'};
+
+#define IPC_HEADER_SIZE (sizeof(ipc_magic) + 8)
+
+struct ipc_client {
+	struct wl_event_source *event_source;
+	struct wl_event_source *writable_event_source;
+	int fd;
+	enum ipc_command_type subscribed_events;
+	size_t write_buffer_len;
+	size_t write_buffer_size;
+	char *write_buffer;
+	// The following are for storing data between event_loop calls
+	uint32_t pending_length;
+	enum ipc_command_type pending_type;
+};
+
+int ipc_handle_connection(int fd, uint32_t mask, void *data);
+int ipc_client_handle_readable(int client_fd, uint32_t mask, void *data);
+void ipc_client_handle_command(struct ipc_client *client, uint32_t payload_length,
+	enum ipc_command_type payload_type);
+bool ipc_send_reply(struct ipc_client *client, enum ipc_command_type payload_type,
+	const char *payload, uint32_t payload_length);
+/*
+int ipc_client_handle_writable(int client_fd, uint32_t mask, void *data);
+void ipc_client_disconnect(struct ipc_client *client);
+*/
+
 /* function declarations */
+static void ipc_event_window(Client *window, const char *change);
+static void ipc_event_shutdown(const char *reason);
 static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
 		int32_t exclusive, int32_t margin_top, int32_t margin_right,
@@ -289,6 +374,7 @@ static void updatemons(struct wl_listener *listener, void *data);
 static void updatetitle(struct wl_listener *listener, void *data);
 static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
+static void viewall(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
 static Monitor *xytomon(double x, double y);
 static struct wlr_scene_node *xytonode(double x, double y, struct wlr_surface **psurface,
@@ -373,6 +459,9 @@ static Atom netatom[NetLast];
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+/* i3 commands compatibility layer */
+#include "commands.c"
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -1075,6 +1164,7 @@ destroynotify(struct wl_listener *listener, void *data)
 	} else
 #endif
 		wl_list_remove(&c->commit.link);
+	ipc_event_window(c, "close");
 	free(c);
 }
 
@@ -1153,6 +1243,7 @@ focusclient(Client *c, int lift)
 		}
 	}
 
+	ipc_event_window(c, "focus");
 	printstatus();
 	wlr_idle_set_enabled(idle, seat, wl_list_empty(&idle_inhibit_mgr->inhibitors));
 
@@ -1412,6 +1503,7 @@ mapnotify(struct wl_listener *listener, void *data)
 
 	/* Set initial monitor, tags, floating status, and focus */
 	applyrules(c);
+	ipc_event_window(c, "new");
 	printstatus();
 
 	if (c->isfullscreen)
@@ -1662,6 +1754,41 @@ printstatus(void)
 	fflush(stdout);
 }
 
+void ipc_client_disconnect(struct ipc_client *client) {
+	int i = 0;
+
+	shutdown(client->fd, SHUT_RDWR);
+
+	wl_event_source_remove(client->event_source);
+	if (client->writable_event_source) {
+		wl_event_source_remove(client->writable_event_source);
+	}
+	while (i < ipc_client_list->length && ipc_client_list->items[i] != client) {
+		i++;
+	}
+	list_del(ipc_client_list, i);
+	free(client->write_buffer);
+	close(client->fd);
+	free(client);
+}
+
+static void handle_display_destroy(struct wl_listener *listener, void *data) {
+	if (ipc_event_source) {
+		wl_event_source_remove(ipc_event_source);
+	}
+	close(ipc_socket);
+	unlink(ipc_sockaddr->sun_path);
+
+	while (ipc_client_list->length) {
+		ipc_client_disconnect(ipc_client_list->items[ipc_client_list->length-1]);
+	}
+	list_free(ipc_client_list);
+
+	free(ipc_sockaddr);
+
+	wl_list_remove(&ipc_display_destroy.link);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1747,6 +1874,879 @@ resize(Client *c, int x, int y, int w, int h, int interact)
 			c->geom.height - 2 * c->bw);
 }
 
+static bool ipc_has_event_listeners(enum ipc_command_type event) {
+	for (int i = 0; i < ipc_client_list->length; i++) {
+		struct ipc_client *client = ipc_client_list->items[i];
+		if ((client->subscribed_events & event_mask(event)) != 0) {
+			return true;
+		}
+	}
+	return false;
+}
+
+static void ipc_send_event(const char *json_string, enum ipc_command_type event) {
+	struct ipc_client *client;
+	for (int i = 0; i < ipc_client_list->length; i++) {
+		client = ipc_client_list->items[i];
+		if ((client->subscribed_events & event_mask(event)) == 0) {
+			continue;
+		}
+		if (!ipc_send_reply(client, event, json_string,
+				(uint32_t)strlen(json_string))) {
+			fprintf(stderr, "Unable to send reply to IPC client");
+			/* ipc_send_reply destroys client on error, which also
+			 * removes it from the list, so we need to process
+			 * current index again */
+			i--;
+		}
+	}
+}
+
+static void ipc_event_tick(const char *payload) {
+	json_object *json;
+	const char *json_string;
+	if (!ipc_has_event_listeners(IPC_EVENT_TICK)) {
+		return;
+	}
+
+	json = json_object_new_object();
+	json_object_object_add(json, "first", json_object_new_boolean(false));
+	json_object_object_add(json, "payload", json_object_new_string(payload));
+
+	json_string = json_object_to_json_string(json);
+	ipc_send_event(json_string, IPC_EVENT_TICK);
+	json_object_put(json);
+}
+
+struct sockaddr_un *ipc_user_sockaddr(void) {
+	int path_size;
+	struct sockaddr_un *ipc_sockaddr = malloc(sizeof(struct sockaddr_un));
+	// Env var typically set by logind, e.g. "/run/user/<user-id>"
+	const char *dir = getenv("XDG_RUNTIME_DIR");
+
+	if (ipc_sockaddr == NULL) {
+		die("Can't allocate ipc_sockaddr");
+	}
+
+	ipc_sockaddr->sun_family = AF_UNIX;
+	path_size = sizeof(ipc_sockaddr->sun_path);
+
+	if (!dir) {
+		dir = "/tmp";
+	}
+	if (path_size <= snprintf(ipc_sockaddr->sun_path, path_size,
+			"%s/sway-ipc.%u.%i.sock", dir, getuid(), getpid())) {
+		die("Socket path won't fit into ipc_sockaddr->sun_path");
+	}
+
+	return ipc_sockaddr;
+}
+
+int ipc_client_handle_writable(int client_fd, uint32_t mask, void *data) {
+	ssize_t written;
+	struct ipc_client *client = data;
+
+	if (mask & WL_EVENT_ERROR) {
+		fprintf(stderr, "IPC Client socket error, removing client");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	if (mask & WL_EVENT_HANGUP) {
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	if (client->write_buffer_len <= 0) {
+		return 0;
+	}
+
+	written = write(client->fd, client->write_buffer, client->write_buffer_len);
+
+	if (written == -1 && errno == EAGAIN) {
+		return 0;
+	} else if (written == -1) {
+		fprintf(stderr, "Unable to send data from queue to IPC client");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	memmove(client->write_buffer, client->write_buffer + written, client->write_buffer_len - written);
+	client->write_buffer_len -= written;
+
+	if (client->write_buffer_len == 0 && client->writable_event_source) {
+		wl_event_source_remove(client->writable_event_source);
+		client->writable_event_source = NULL;
+	}
+
+	return 0;
+}
+
+static const char *ipc_json_output_transform_description(enum wl_output_transform transform) {
+	switch (transform) {
+	case WL_OUTPUT_TRANSFORM_NORMAL:
+		return "normal";
+	case WL_OUTPUT_TRANSFORM_90:
+		// Sway uses clockwise transforms, while WL_OUTPUT_TRANSFORM_* describes
+		// anti-clockwise transforms.
+		return "270";
+	case WL_OUTPUT_TRANSFORM_180:
+		return "180";
+	case WL_OUTPUT_TRANSFORM_270:
+		// Transform also inverted here.
+		return "90";
+	case WL_OUTPUT_TRANSFORM_FLIPPED:
+		return "flipped";
+	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+		// Inverted.
+		return "flipped-270";
+	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+		return "flipped-180";
+	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+		// Inverted.
+		return "flipped-90";
+	}
+	return NULL;
+}
+
+
+static const char *ipc_json_output_adaptive_sync_status_description(
+		enum wlr_output_adaptive_sync_status status) {
+	switch (status) {
+	case WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED:
+		return "disabled";
+	case WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED:
+		return "enabled";
+	case WLR_OUTPUT_ADAPTIVE_SYNC_UNKNOWN:
+		return "unknown";
+	}
+	return NULL;
+}
+
+static json_object *ipc_json_create_rect(struct wlr_box *box) {
+	json_object *rect = json_object_new_object();
+
+	json_object_object_add(rect, "x", json_object_new_int(box->x));
+	json_object_object_add(rect, "y", json_object_new_int(box->y));
+	json_object_object_add(rect, "width", json_object_new_int(box->width));
+	json_object_object_add(rect, "height", json_object_new_int(box->height));
+
+	return rect;
+}
+
+static json_object *ipc_json_create_empty_rect(void) {
+	struct wlr_box empty = {0, 0, 0, 0};
+
+	return ipc_json_create_rect(&empty);
+}
+
+static json_object *ipc_json_create_node(intptr_t id, const char* type, const char *name,
+		bool focused, struct wlr_box *box) {
+	json_object *object = json_object_new_object();
+
+	json_object_object_add(object, "id", json_object_new_int(abs(id)));
+	json_object_object_add(object, "type", json_object_new_string(type));
+	json_object_object_add(object, "orientation",
+			json_object_new_string("none"));
+	json_object_object_add(object, "percent", NULL);
+	json_object_object_add(object, "urgent", json_object_new_boolean(false));
+	json_object_object_add(object, "marks", json_object_new_array());
+	json_object_object_add(object, "focused", json_object_new_boolean(focused));
+	json_object_object_add(object, "layout",
+			json_object_new_string("splith"));
+
+	// set default values to be compatible with i3
+	json_object_object_add(object, "border",
+			json_object_new_string("none"));
+	json_object_object_add(object, "current_border_width",
+			json_object_new_int(0));
+	json_object_object_add(object, "rect", ipc_json_create_rect(box));
+	json_object_object_add(object, "deco_rect", ipc_json_create_empty_rect());
+	json_object_object_add(object, "window_rect", ipc_json_create_empty_rect());
+	json_object_object_add(object, "geometry", ipc_json_create_empty_rect());
+	json_object_object_add(object, "name",
+			name ? json_object_new_string(name) : NULL);
+	json_object_object_add(object, "window", NULL);
+	json_object_object_add(object, "nodes", json_object_new_array());
+	json_object_object_add(object, "floating_nodes", json_object_new_array());
+	json_object_object_add(object, "focus", json_object_new_array());
+	json_object_object_add(object, "fullscreen_mode", json_object_new_int(0));
+	json_object_object_add(object, "sticky", json_object_new_boolean(false));
+
+	return object;
+}
+
+json_object* ipc_json_describe_client(Client *c) {
+	json_object *object;
+	bool visible;
+	Monitor *tempm;
+	struct wlr_box deco_box = {c->geom.x-borderpx, c->geom.y-borderpx, c->geom.width + borderpx, c->geom.height + borderpx};
+	object = ipc_json_create_node((intptr_t)c, "con", client_get_title(c), seat->keyboard_state.focused_surface == client_surface(c), &c->geom);
+	if (c->isfloating) {
+		json_object_object_add(object, "type",
+				json_object_new_string("floating_con"));
+	}
+
+	json_object_object_add(object, "layout",
+			json_object_new_string("none"));
+
+	json_object_object_add(object, "orientation",
+			json_object_new_string("none"));
+
+	json_object_object_add(object, "urgent", json_object_new_boolean(c->isurgent));
+
+	json_object_object_add(object, "fullscreen_mode",
+			json_object_new_int(c->isfullscreen));
+
+	if (deco_box.width != 0 && deco_box.height != 0) {
+		double percent = ((double)c->geom.width / deco_box.width)
+				* ((double)c->geom.height / deco_box.height);
+		json_object_object_add(object, "percent", json_object_new_double(percent));
+	}
+
+	json_object_object_add(object, "border",
+			json_object_new_string("pixel"));
+	json_object_object_add(object, "current_border_width",
+			json_object_new_int(borderpx));
+	json_object_object_add(object, "floating_nodes", json_object_new_array());
+
+	json_object_object_add(object, "deco_rect", ipc_json_create_rect(&deco_box));
+
+	/*
+	json_object *marks = json_object_new_array();
+	list_t *con_marks = c->marks;
+	for (int i = 0; i < con_marks->length; ++i) {
+		json_object_array_add(marks, json_object_new_string(con_marks->items[i]));
+	}
+
+	json_object_object_add(object, "marks", marks);
+	*/
+
+	// json_object_object_add(object, "pid", json_object_new_int(client_get_pid(c)));
+
+	const char *app_id = client_get_appid(c);
+	json_object_object_add(object, "app_id",
+			app_id ? json_object_new_string(app_id) : NULL);
+
+	wl_list_for_each(tempm, &mons, link) {
+		if (VISIBLEON(c, tempm)) {
+			visible = true;
+		}
+	}
+	json_object_object_add(object, "visible", json_object_new_boolean(visible));
+
+	json_object_object_add(object, "window_rect", ipc_json_create_rect(&c->geom));
+
+	json_object_object_add(object, "geometry", ipc_json_create_rect(&c->geom));
+
+	json_object_object_add(object, "max_render_time", json_object_new_int(0));
+
+	/*
+	json_object_object_add(object, "shell", json_object_new_string(view_get_shell(c->view)));
+
+	json_object_object_add(object, "inhibit_idle",
+		json_object_new_boolean(view_inhibit_idle(c->view)));
+
+	json_object *idle_inhibitors = json_object_new_object();
+
+	struct sway_idle_inhibitor_v1 *user_inhibitor =
+		sway_idle_inhibit_v1_user_inhibitor_for_view(c->view);
+
+	if (user_inhibitor) {
+		json_object_object_add(idle_inhibitors, "user",
+			json_object_new_string(
+				ipc_json_user_idle_inhibitor_description(user_inhibitor->mode)));
+	} else {
+		json_object_object_add(idle_inhibitors, "user",
+			json_object_new_string("none"));
+	}
+
+	struct sway_idle_inhibitor_v1 *application_inhibitor =
+		sway_idle_inhibit_v1_application_inhibitor_for_view(c->view);
+
+	if (application_inhibitor) {
+		json_object_object_add(idle_inhibitors, "application",
+			json_object_new_string("enabled"));
+	} else {
+		json_object_object_add(idle_inhibitors, "application",
+			json_object_new_string("none"));
+	}
+
+	json_object_object_add(object, "idle_inhibitors", idle_inhibitors);
+
+#if XWAYLAND
+	if (c->view->type == SWAY_VIEW_XWAYLAND) {
+		json_object_object_add(object, "window",
+				json_object_new_int(view_get_x11_window_id(c->view)));
+
+		json_object *window_props = json_object_new_object();
+
+		const char *class = view_get_class(c->view);
+		if (class) {
+			json_object_object_add(window_props, "class", json_object_new_string(class));
+		}
+		const char *instance = view_get_instance(c->view);
+		if (instance) {
+			json_object_object_add(window_props, "instance", json_object_new_string(instance));
+		}
+		if (c->title) {
+			json_object_object_add(window_props, "title", json_object_new_string(c->title));
+		}
+
+		// the transient_for key is always present in i3's output
+		uint32_t parent_id = view_get_x11_parent_id(c->view);
+		json_object_object_add(window_props, "transient_for",
+				parent_id ? json_object_new_int(parent_id) : NULL);
+
+		const char *role = view_get_window_role(c->view);
+		if (role) {
+			json_object_object_add(window_props, "window_role", json_object_new_string(role));
+		}
+
+		uint32_t window_type = view_get_window_type(c->view);
+		if (window_type) {
+			json_object_object_add(window_props, "window_type",
+				json_object_new_string(
+					ipc_json_xwindow_type_description(c->view)));
+		}
+
+		json_object_object_add(object, "window_properties", window_props);
+	}
+#endif
+	*/
+	return object;
+}
+
+void ipc_event_shutdown(const char *reason) {
+	json_object *json;
+	const char *json_string;
+	if (!ipc_has_event_listeners(IPC_EVENT_SHUTDOWN)) {
+		return;
+	}
+
+	json = json_object_new_object();
+	json_object_object_add(json, "change", json_object_new_string(reason));
+
+	json_string = json_object_to_json_string(json);
+	ipc_send_event(json_string, IPC_EVENT_SHUTDOWN);
+	json_object_put(json);
+}
+
+void ipc_event_window(Client *window, const char *change) {
+	json_object *obj;
+	const char *json_string; 
+	if (!ipc_has_event_listeners(IPC_EVENT_WINDOW) || window == NULL) {
+		return;
+	}
+	obj = json_object_new_object();
+	json_object_object_add(obj, "change", json_object_new_string(change));
+	json_object_object_add(obj, "container", ipc_json_describe_client(window));
+
+	json_string = json_object_to_json_string(obj);
+	ipc_send_event(json_string, IPC_EVENT_WINDOW);
+	json_object_put(obj);
+}
+
+json_object* ipc_get_workspaces_callback(ssize_t i, Monitor *m) {
+	Monitor *tempm;
+	Client *c;
+	bool visible = false;
+	json_object *children = json_object_new_array();
+	json_object *workspace_json = ipc_json_create_node((intptr_t)m, "workspace", tags[i], (1 << i) & selmon->tagset[selmon->seltags], &m->w);
+
+	wl_list_for_each(tempm, &mons, link) {
+		if ((1 << i) & tempm->tagset[tempm->seltags]) {
+			visible = true;
+		}
+	}
+
+
+	json_object_object_add(workspace_json, "num", json_object_new_int(i + 1));
+	json_object_object_add(workspace_json, "fullscreen_mode", json_object_new_int(1));
+	json_object_object_add(workspace_json, "representation", json_object_new_string("D[]"));
+	json_object_object_add(workspace_json, "visible", json_object_new_boolean(visible));
+	json_object_object_add(workspace_json, "output", json_object_new_string(selmon->wlr_output->name));
+	wl_list_for_each(c, &clients, link) {
+		if (c->tags == (1 << i)) {
+			json_object_array_add(children, ipc_json_describe_client(c));
+		}
+	}
+	json_object_object_add(workspace_json, "nodes", children);
+	return workspace_json;
+}
+
+json_object* ipc_json_describe_output(Monitor *m) {
+	json_object *object = ipc_json_create_node((intptr_t)m, "output", m->wlr_output->name, false, &m->w);
+	struct wlr_output *wlr_output = m->wlr_output;
+	struct wlr_output_mode *mode;
+	ssize_t i;
+	const char *adaptive_sync_status;
+	json_object *modes_array = json_object_new_array();
+	json_object *children = json_object_new_array();
+	json_object *current_mode_object = json_object_new_object();
+
+	json_object_object_add(object, "primary", json_object_new_boolean(false));
+	json_object_object_add(object, "make",
+			json_object_new_string(wlr_output->make));
+	json_object_object_add(object, "model",
+			json_object_new_string(wlr_output->model));
+	json_object_object_add(object, "serial",
+			json_object_new_string(wlr_output->serial));
+
+	wl_list_for_each(mode, &wlr_output->modes, link) {
+		json_object *mode_object = json_object_new_object();
+		json_object_object_add(mode_object, "width",
+			json_object_new_int(mode->width));
+		json_object_object_add(mode_object, "height",
+			json_object_new_int(mode->height));
+		json_object_object_add(mode_object, "refresh",
+			json_object_new_int(mode->refresh));
+		json_object_array_add(modes_array, mode_object);
+	}
+	json_object_object_add(object, "modes", modes_array);
+	json_object_object_add(object, "active", json_object_new_boolean(true));
+	json_object_object_add(object, "dpms",
+			json_object_new_boolean(wlr_output->enabled));
+	json_object_object_add(object, "layout", json_object_new_string("output"));
+	json_object_object_add(object, "orientation",
+			json_object_new_string("none"));
+	json_object_object_add(object, "scale",
+			json_object_new_double(wlr_output->scale));
+	/*
+	json_object_object_add(object, "scale_filter",
+		json_object_new_string(
+			sway_output_scale_filter_to_string(output->scale_filter)));
+	*/
+	json_object_object_add(object, "transform",
+		json_object_new_string(
+			ipc_json_output_transform_description(wlr_output->transform)));
+	adaptive_sync_status =
+		ipc_json_output_adaptive_sync_status_description(
+			wlr_output->adaptive_sync_status);
+	json_object_object_add(object, "adaptive_sync_status",
+		json_object_new_string(adaptive_sync_status));
+
+
+	for (i = 0; i < LENGTH(tags); i++) {
+		if ((1 << i) & m->tagset[m->seltags]) {
+	json_object_object_add(object, "current_workspace",
+			json_object_new_string(tags[i]));
+			break;
+		}
+	}
+
+	json_object_object_add(current_mode_object, "width",
+		json_object_new_int(wlr_output->width));
+	json_object_object_add(current_mode_object, "height",
+		json_object_new_int(wlr_output->height));
+	json_object_object_add(current_mode_object, "refresh",
+		json_object_new_int(wlr_output->refresh));
+	json_object_object_add(object, "current_mode", current_mode_object);
+
+	if (m->m.width != 0 && m->m.height != 0) {
+		double percent = ((double)m->w.width / m->m.width)
+				* ((double)m->w.height / m->m.height);
+		json_object_object_add(object, "percent", json_object_new_double(percent));
+	}
+
+	for (i = 0; i < LENGTH(tags); i++) {
+		json_object_array_add(children, ipc_get_workspaces_callback(i, m));
+	}
+	json_object_object_add(object, "nodes", children);
+
+	return object;
+}
+
+json_object* ipc_json_node_tree(void) {
+	Monitor *tempm;
+	json_object *full_obj;
+	json_object* children = json_object_new_array();
+	struct wlr_box full_box = {0, 0, 0, 0};
+	wl_list_for_each(tempm, &mons, link) {
+		if (tempm->m.x < full_box.x) {
+			full_box.x = tempm->m.x;
+		}
+		if (tempm->m.y < full_box.y) {
+			full_box.y = tempm->m.y;
+		}
+		if (tempm->m.x + tempm->m.width > full_box.width) {
+			full_box.width = tempm->m.x + tempm->m.width;
+		}
+		if (tempm->m.y + tempm->m.height > full_box.height) {
+			full_box.height = tempm->m.y + tempm->m.height;
+		}
+	}
+	full_box.width = full_box.width - full_box.x;
+	full_box.height = full_box.height - full_box.y;
+	full_obj = ipc_json_create_node(1, "root", "root", false, &full_box);
+	wl_list_for_each(tempm, &mons, link) {
+		json_object_array_add(children, ipc_json_describe_output(tempm));	
+	}
+	json_object_object_add(full_obj, "nodes", children);
+	return full_obj;
+}
+
+void ipc_client_handle_command(struct ipc_client *client, uint32_t payload_length,
+		enum ipc_command_type payload_type) {
+	char *buf;
+	const char msg[] = "{\"success\": true}";
+	bool is_tick;
+	list_t *res_list;
+	ssize_t i;
+	const char *json_string;
+	if (client == NULL) {
+		return;
+	}
+
+	buf = malloc(payload_length + 1);
+	if (!buf) {
+		fprintf(stderr, "Unable to allocate IPC payload");
+		ipc_client_disconnect(client);
+		return;
+	}
+	if (payload_length > 0) {
+		// Payload should be fully available
+		ssize_t received = recv(client->fd, buf, payload_length, 0);
+		if (received == -1)
+		{
+			fprintf(stderr, "Unable to receive payload from IPC client");
+			ipc_client_disconnect(client);
+			free(buf);
+			return;
+		}
+	}
+	buf[payload_length] = '\0';
+	switch (payload_type) {
+	case IPC_COMMAND:
+	{
+		char *line = strtok(buf, "\n");
+		while (line) {
+			size_t line_length = strlen(line);
+			if (line + line_length >= buf + payload_length) {
+				break;
+			}
+			line[line_length] = ';';
+			line = strtok(NULL, "\n");
+		}
+
+		res_list = execute_command(buf, NULL);
+		buf = cmd_results_to_json(res_list);
+		i = strlen(buf);
+		ipc_send_reply(client, payload_type, buf, (uint32_t)i);
+		while (res_list->length) {
+			struct cmd_results *results = res_list->items[0];
+			free_cmd_results(results);
+			list_del(res_list, 0);
+		}
+		list_free(res_list);
+		goto exit_cleanup;
+	}
+
+	case IPC_SEND_TICK:
+	{
+		ipc_event_tick(buf);
+		ipc_send_reply(client, payload_type, "{\"success\": true}", 17);
+		goto exit_cleanup;
+	}
+
+	case IPC_GET_WORKSPACES:
+	{
+		json_object *workspaces = json_object_new_array();
+		for (i = 0; i < LENGTH(tags); i++) {
+			json_object_array_add(workspaces, ipc_get_workspaces_callback(i, selmon));	
+		}
+		json_string = json_object_to_json_string(workspaces);
+		ipc_send_reply(client, payload_type, json_string,
+			(uint32_t)strlen(json_string));
+		json_object_put(workspaces); // free
+		goto exit_cleanup;
+	}
+
+	case IPC_SUBSCRIBE:
+	{
+		// TODO: Check if they're permitted to use these events
+		struct json_object *request = json_tokener_parse(buf);
+		if (request == NULL || !json_object_is_type(request, json_type_array)) {
+			const char msg[] = "{\"success\": false}";
+			ipc_send_reply(client, payload_type, msg, strlen(msg));
+			fprintf(stderr, "Failed to parse subscribe request");
+			goto exit_cleanup;
+		}
+
+		is_tick = false;
+		// parse requested event types
+		for (size_t i = 0; i < json_object_array_length(request); i++) {
+			const char *event_type = json_object_get_string(json_object_array_get_idx(request, i));
+			if (strcmp(event_type, "workspace") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_WORKSPACE);
+			} else if (strcmp(event_type, "barconfig_update") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_BARCONFIG_UPDATE);
+			} else if (strcmp(event_type, "bar_state_update") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_BAR_STATE_UPDATE);
+			} else if (strcmp(event_type, "mode") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_MODE);
+			} else if (strcmp(event_type, "shutdown") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_SHUTDOWN);
+			} else if (strcmp(event_type, "window") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_WINDOW);
+			} else if (strcmp(event_type, "binding") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_BINDING);
+			} else if (strcmp(event_type, "tick") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_TICK);
+				is_tick = true;
+			} else if (strcmp(event_type, "input") == 0) {
+				client->subscribed_events |= event_mask(IPC_EVENT_INPUT);
+			} else {
+				const char msg[] = "{\"success\": false}";
+				ipc_send_reply(client, payload_type, msg, strlen(msg));
+				json_object_put(request);
+				fprintf(stderr, "Unsupported event type in subscribe request");
+				goto exit_cleanup;
+			}
+		}
+
+		json_object_put(request);
+		ipc_send_reply(client, payload_type, msg, strlen(msg));
+		if (is_tick) {
+			const char tickmsg[] = "{\"first\": true, \"payload\": \"\"}";
+			ipc_send_reply(client, IPC_EVENT_TICK, tickmsg,
+				strlen(tickmsg));
+		}
+		goto exit_cleanup;
+	}
+
+	case IPC_GET_TREE:
+	{
+		json_object *tree = ipc_json_node_tree();
+		const char *json_string = json_object_to_json_string(tree);
+		ipc_send_reply(client, payload_type, json_string,
+			(uint32_t)strlen(json_string));
+		json_object_put(tree);
+		goto exit_cleanup;
+	}
+
+
+	default:
+		fprintf(stderr, "Unknown IPC command type %x", payload_type);
+		goto exit_cleanup;
+	}
+
+exit_cleanup:
+	free(buf);
+	return;
+}
+
+void ipc_init(void) {
+	ipc_socket = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (ipc_socket == -1) {
+		die("Unable to create IPC socket");
+	}
+	if (fcntl(ipc_socket, F_SETFD, FD_CLOEXEC) == -1) {
+		die("Unable to set CLOEXEC on IPC socket");
+	}
+	if (fcntl(ipc_socket, F_SETFL, O_NONBLOCK) == -1) {
+		die("Unable to set NONBLOCK on IPC socket");
+	}
+
+	ipc_sockaddr = ipc_user_sockaddr();
+
+	// We want to use socket name set by user, not existing socket from another sway instance.
+	if (getenv("SWAYSOCK") != NULL && access(getenv("SWAYSOCK"), F_OK) == -1) {
+		strncpy(ipc_sockaddr->sun_path, getenv("SWAYSOCK"), sizeof(ipc_sockaddr->sun_path) - 1);
+		ipc_sockaddr->sun_path[sizeof(ipc_sockaddr->sun_path) - 1] = 0;
+	}
+
+	unlink(ipc_sockaddr->sun_path);
+	if (bind(ipc_socket, (struct sockaddr *)ipc_sockaddr, sizeof(*ipc_sockaddr)) == -1) {
+		die("Unable to bind IPC socket");
+	}
+
+	if (listen(ipc_socket, 3) == -1) {
+		die("Unable to listen on IPC socket");
+	}
+
+	// Set i3 IPC socket path so that i3-msg works out of the box
+	setenv("I3SOCK", ipc_sockaddr->sun_path, 1);
+	setenv("SWAYSOCK", ipc_sockaddr->sun_path, 1);
+
+	ipc_client_list = create_list();
+
+	ipc_display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(dpy, &ipc_display_destroy);
+
+	ipc_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy), ipc_socket,
+			WL_EVENT_READABLE, ipc_handle_connection, NULL);
+}
+
+int ipc_handle_connection(int fd, uint32_t mask, void *data) {
+	int flags;
+	int client_fd;
+	struct ipc_client *client;
+
+	(void) fd;
+	if (!(mask == WL_EVENT_READABLE)) {
+		return 0;
+	}
+
+	client_fd = accept(ipc_socket, NULL, NULL);
+	if (client_fd == -1) {
+		fprintf(stderr, "Unable to accept IPC client connection");
+		return 0;
+	}
+
+	if ((flags = fcntl(client_fd, F_GETFD)) == -1
+			|| fcntl(client_fd, F_SETFD, flags|FD_CLOEXEC) == -1) {
+		fprintf(stderr, "Unable to set CLOEXEC on IPC client socket");
+		close(client_fd);
+		return 0;
+	}
+	if ((flags = fcntl(client_fd, F_GETFL)) == -1
+			|| fcntl(client_fd, F_SETFL, flags|O_NONBLOCK) == -1) {
+		fprintf(stderr, "Unable to set NONBLOCK on IPC client socket");
+		close(client_fd);
+		return 0;
+	}
+
+	client = malloc(sizeof(struct ipc_client));
+	if (!client) {
+		fprintf(stderr, "Unable to allocate ipc client");
+		close(client_fd);
+		return 0;
+	}
+	client->pending_length = 0;
+	client->fd = client_fd;
+	client->subscribed_events = 0;
+	client->event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
+			client_fd, WL_EVENT_READABLE, ipc_client_handle_readable, client);
+	client->writable_event_source = NULL;
+
+	client->write_buffer_size = 128;
+	client->write_buffer_len = 0;
+	client->write_buffer = malloc(client->write_buffer_size);
+	if (!client->write_buffer) {
+		fprintf(stderr, "Unable to allocate ipc client write buffer");
+		close(client_fd);
+		return 0;
+	}
+
+	list_add(ipc_client_list, client);
+	return 0;
+}
+
+int ipc_client_handle_readable(int client_fd, uint32_t mask, void *data) {
+	int read_available;
+	uint8_t buf[IPC_HEADER_SIZE];
+	ssize_t received;
+	struct ipc_client *client = data;
+
+	if (mask & WL_EVENT_ERROR) {
+		fprintf(stderr, "IPC Client socket error, removing client");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	if (mask & WL_EVENT_HANGUP) {
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	if (ioctl(client_fd, FIONREAD, &read_available) == -1) {
+		fprintf(stderr, "Unable to read IPC socket buffer size");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	// Wait for the rest of the command payload in case the header has already been read
+	if (client->pending_length > 0) {
+		if ((uint32_t)read_available >= client->pending_length) {
+			// Reset pending values.
+			uint32_t pending_length = client->pending_length;
+			enum ipc_command_type pending_type = client->pending_type;
+			client->pending_length = 0;
+			ipc_client_handle_command(client, pending_length, pending_type);
+		}
+		return 0;
+	}
+
+	if (read_available < (int) IPC_HEADER_SIZE) {
+		return 0;
+	}
+
+	// Should be fully available, because read_available >= IPC_HEADER_SIZE
+	received = recv(client_fd, buf, IPC_HEADER_SIZE, 0);
+	if (received == -1) {
+		fprintf(stderr, "Unable to receive header from IPC client");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	if (memcmp(buf, ipc_magic, sizeof(ipc_magic)) != 0) {
+		fprintf(stderr, "IPC header check failed");
+		ipc_client_disconnect(client);
+		return 0;
+	}
+
+	memcpy(&client->pending_length, buf + sizeof(ipc_magic), sizeof(uint32_t));
+	memcpy(&client->pending_type, buf + sizeof(ipc_magic) + sizeof(uint32_t), sizeof(uint32_t));
+
+	if (read_available - received >= (long)client->pending_length) {
+		// Reset pending values.
+		uint32_t pending_length = client->pending_length;
+		enum ipc_command_type pending_type = client->pending_type;
+		client->pending_length = 0;
+		ipc_client_handle_command(client, pending_length, pending_type);
+	}
+
+	return 0;
+}
+
+bool ipc_send_reply(struct ipc_client *client, enum ipc_command_type payload_type,
+		const char *payload, uint32_t payload_length) {
+	char data[IPC_HEADER_SIZE];
+	char *new_buffer;
+	if (payload == NULL) {
+		return false;
+	}
+
+
+	memcpy(data, ipc_magic, sizeof(ipc_magic));
+	memcpy(data + sizeof(ipc_magic), &payload_length, sizeof(payload_length));
+	memcpy(data + sizeof(ipc_magic) + sizeof(payload_length), &payload_type, sizeof(payload_type));
+
+	while (client->write_buffer_len + IPC_HEADER_SIZE + payload_length >=
+				 client->write_buffer_size) {
+		client->write_buffer_size *= 2;
+	}
+
+	if (client->write_buffer_size > 4e6) { // 4 MB
+		fprintf(stderr, "Client write buffer too big (%zu), disconnecting client",
+				client->write_buffer_size);
+		ipc_client_disconnect(client);
+		return false;
+	}
+
+	new_buffer = realloc(client->write_buffer, client->write_buffer_size);
+	if (!new_buffer) {
+		fprintf(stderr, "Unable to reallocate ipc client write buffer");
+		ipc_client_disconnect(client);
+		return false;
+	}
+	client->write_buffer = new_buffer;
+
+	memcpy(client->write_buffer + client->write_buffer_len, data, IPC_HEADER_SIZE);
+	client->write_buffer_len += IPC_HEADER_SIZE;
+	memcpy(client->write_buffer + client->write_buffer_len, payload, payload_length);
+	client->write_buffer_len += payload_length;
+
+	if (!client->writable_event_source) {
+		client->writable_event_source = wl_event_loop_add_fd(
+				wl_display_get_event_loop(dpy), client->fd, WL_EVENT_WRITABLE,
+				ipc_client_handle_writable, client);
+	}
+
+	return true;
+}
+
 void
 run(char *startup_cmd)
 {
@@ -1756,6 +2756,7 @@ run(char *startup_cmd)
 	const char *socket = wl_display_add_socket_auto(dpy);
 	if (!socket)
 		die("startup: display_add_socket_auto");
+	ipc_init();
 	setenv("WAYLAND_DISPLAY", socket, 1);
 
 	/* Now that the socket exists, run the startup command */
@@ -1842,6 +2843,7 @@ setfloating(Client *c, int floating)
 	c->isfloating = floating;
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
 	arrange(c->mon);
+	ipc_event_window(c, "floating");
 	printstatus();
 }
 
@@ -1861,6 +2863,7 @@ setfullscreen(Client *c, int fullscreen)
 		resize(c, c->prev.x, c->prev.y, c->prev.width, c->prev.height, 0);
 	}
 	arrange(c->mon);
+	ipc_event_window(c, "fullscreen_mode");
 	printstatus();
 }
 
@@ -2237,13 +3240,28 @@ toggletag(const Arg *arg)
 void
 toggleview(const Arg *arg)
 {
-	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-
+	json_object *obj;
+	const char *json_string;
+	unsigned int tag, newtagset;
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		obj = json_object_new_object();
+		json_object_object_add(obj, "change", json_object_new_string("focus"));
+		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, selmon));
+	}
+	i3_tag = arg->ui;
+	tag = 1 << arg->ui;
+	newtagset = selmon->tagset[selmon->seltags] ^ (tag & TAGMASK);
 	if (newtagset) {
 		selmon->tagset[selmon->seltags] = newtagset;
 		focusclient(focustop(selmon), 1);
 		arrange(selmon);
 	}
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
+		json_string = json_object_to_json_string(obj);
+		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
+		json_object_put(obj);
+	}
 	printstatus();
 }
 
@@ -2334,6 +3352,7 @@ updatetitle(struct wl_listener *listener, void *data)
 	Client *c = wl_container_of(listener, c, set_title);
 	if (c == focustop(c->mon))
 		printstatus();
+	ipc_event_window(c, "title");
 }
 
 void
@@ -2343,23 +3362,195 @@ urgent(struct wl_listener *listener, void *data)
 	Client *c = client_from_wlr_surface(event->surface);
 	if (c != selclient()) {
 		c->isurgent = 1;
+		ipc_event_window(c, "urgent");
 		printstatus();
 	}
 }
 
 void
-view(const Arg *arg)
+switchtag(unsigned int tag, Monitor *m)
 {
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+	json_object *obj;
+	const char *json_string;
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		obj = json_object_new_object();
+		json_object_object_add(obj, "change", json_object_new_string("focus"));
+		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, m));
+	}
+	i3_tag = tag;
+	tag = 1 << tag;
+	if ((tag & TAGMASK) == m->tagset[m->seltags])
+		return;
+	m->seltags ^= 1; /* toggle sel tagset */
+	if (tag & TAGMASK)
+		m->tagset[m->seltags] = tag & TAGMASK;
+	focusclient(focustop(m), 1);
+	arrange(m);
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
+		json_string = json_object_to_json_string(obj);
+		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
+		json_object_put(obj);
+	}
+	printstatus();
+}
+
+void
+viewall(const Arg *arg)
+{
+	json_object *obj;
+	const char *json_string;
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		obj = json_object_new_object();
+		json_object_object_add(obj, "change", json_object_new_string("focus"));
+		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, selmon));
+	}
+	i3_tag = 0;
+	if ((~0 & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+	if (~0 & TAGMASK)
+		selmon->tagset[selmon->seltags] = ~0 & TAGMASK;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
+	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
+		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
+		json_string = json_object_to_json_string(obj);
+		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
+		json_object_put(obj);
+	}
 	printstatus();
 }
 
+struct cmd_results *
+cmd_workspace(int argc, char **argv)
+{
+	struct cmd_results *error = NULL;
+	int output_location = -1;
+	unsigned int i;
+	ssize_t tag;
+	Monitor *m;
+	ssize_t j;
+	char *ws_name;
+	if ((error = checkarg(argc, "workspace", EXPECTED_AT_LEAST, 1))) {
+		return error;
+	}	
+	for (i = 0; i < argc; ++i) {
+		if (strcasecmp(argv[i], "output") == 0) {
+			output_location = i;
+			break;
+		}
+	}
+
+	if (output_location == 0) {
+		return cmd_results_new(CMD_INVALID,
+			"Expected 'workspace <name> output <output>'");
+	} else if (output_location > 0) {
+		if ((error = checkarg(argc, "workspace", EXPECTED_AT_LEAST,
+						output_location + 2))) {
+			return error;
+		}
+		ws_name = join_args(argv, output_location);
+		for (j = 0; j < LENGTH(tags); j++) {
+			if (strcmp(tags[j], ws_name) == 0) {
+				tag = j;
+				break;
+			}
+		}
+		i = output_location + 1;
+		wl_list_for_each(m, &mons, link) {
+			if (i > argc) {
+				break;
+			}
+			if (strcmp(argv[i], m->wlr_output->name) == 0) {
+				switchtag(tag, m);
+			}
+			i++;
+		}
+		free(ws_name);
+	} else {
+		m = selmon;
+		/*
+		if (root->fullscreen_global) {
+			return cmd_results_new(CMD_FAILURE, "workspace",
+				"Can't switch workspaces while fullscreen global");
+		}
+		*/
+
+		/*
+		while (strcasecmp(argv[0], "--no-auto-back-and-forth") == 0) {
+			auto_back_and_forth = false;
+			if ((error = checkarg(--argc, "workspace", EXPECTED_AT_LEAST, 1))) {
+				return error;
+			}
+			++argv;
+		}
+		*/
+
+		if (strcasecmp(argv[0], "number") == 0) {
+			if (argc < 2) {
+				return cmd_results_new(CMD_INVALID,
+						"Expected workspace number");
+			}
+			if (!isdigit(argv[1][0])) {
+				return cmd_results_new(CMD_INVALID,
+						"Invalid workspace number '%s'", argv[1]);
+			}
+			switchtag(atoi(argv[1]), m);
+			/*
+			if (ws && auto_back_and_forth) {
+				ws = workspace_auto_back_and_forth(ws);
+			}
+			*/
+		} /* else if (strcasecmp(argv[0], "next") == 0 ||
+				strcasecmp(argv[0], "prev") == 0 ||
+				strcasecmp(argv[0], "next_on_output") == 0 ||
+				strcasecmp(argv[0], "prev_on_output") == 0 ||
+				strcasecmp(argv[0], "current") == 0) {
+			for (i = 0; i < LENGTH(tags); i++) {
+				if (strcmp(tags[i], argv[0])) {
+					view((Arg*)&i);
+					break;
+				}
+			}
+		
+		}  else if (strcasecmp(argv[0], "back_and_forth") == 0) {
+			if (!seat->prev_workspace_name) {
+				return cmd_results_new(CMD_INVALID,
+						"There is no previous workspace");
+			}
+			for (i = 0; i < LENGTH(tags); i++) {
+				if (strcmp(tags[i], argv[0])) {
+					m->seltags = 1 << (unsigned int)i;
+					break;
+				}
+			}
+		} */ else {
+			char *name = join_args(argv, argc);
+			for (i = 0; i < LENGTH(tags); i++) {
+				if (strcmp(tags[i], name) == 0) {
+					switchtag(i, m);
+					break;
+				}
+			}
+			free(name);
+			/*
+			if (ws && auto_back_and_forth) {
+				ws = workspace_auto_back_and_forth(ws);
+			}
+			*/
+		}
+	}
+	return cmd_results_new(CMD_SUCCESS, NULL);
+}
+
+
+inline void
+view(const Arg *arg)
+{
+	switchtag(arg->ui, selmon);
+}
+
 void
 virtualkeyboard(struct wl_listener *listener, void *data)
 {
@@ -2436,6 +3627,7 @@ zoom(const Arg *arg)
 	wl_list_remove(&sel->link);
 	wl_list_insert(&clients, &sel->link);
 
+	ipc_event_window(sel, "move");
 	focusclient(sel, 1);
 	arrange(selmon);
 }
diff --git a/hmm.log b/hmm.log
new file mode 100644
index 00000000..cbfef147
--- /dev/null
+++ b/hmm.log
@@ -0,0 +1,24 @@
+M 20:24:14.427933    m-lua-scripting ../modules/module-lua-scripting/api/config.c:80:load_components: Failed to open module /usr/local/lib/wireplumber-0.4/libwireplumber-module-logind: /usr/local/lib/wireplumber-0.4/libwireplumber-module-logind.so: cannot open shared object file: No such file or directory
+M 20:24:14.436613          wp-device ../lib/wp/device.c:619:wp_spa_device_new_from_spa_factory: SPA handle 'api.libcamera.enum.manager' could not be loaded; is it installed?
+M 20:24:14.436662   script/libcamera libcamera.lua:168:chunk: PipeWire's libcamera SPA missing or broken. libcamera not supported.
+M 20:24:14.487389          wp-device ../lib/wp/device.c:619:wp_spa_device_new_from_spa_factory: SPA handle 'api.alsa.acp.device' could not be loaded; is it installed?
+W 20:24:14.487436        script/alsa alsa.lua:190:createDevice: Failed to create 'api.alsa.acp.device' device
+W 20:24:14.569268           spa.alsa ../pipewire/spa/plugins/alsa/acp/alsa-ucm.c:976:probe_volumes: Path Mic ACP LED is not a volume or mute control
+dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.a11y.Bus' requested by ':1.6' (uid=1000 pid=6637 comm="waybar")
+dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.a11y.Bus'
+dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.portal.Desktop' requested by ':1.5' (uid=1000 pid=6637 comm="waybar")
+dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.portal.Documents' requested by ':1.8' (uid=1000 pid=6661 comm="/usr/lib/xdg-desktop-portal")
+dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.impl.portal.PermissionStore' requested by ':1.9' (uid=1000 pid=6666 comm="/usr/lib/xdg-document-portal")
+dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.impl.portal.PermissionStore'
+dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.portal.Documents'
+
+** (/usr/lib/xdg-desktop-portal:6661): WARNING **: 20:24:14.719: No skeleton to export
+dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.impl.portal.desktop.wlr' requested by ':1.8' (uid=1000 pid=6661 comm="/usr/lib/xdg-desktop-portal")
+2022/06/08 20:24:14 [ERROR] - config: no config file found
+dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.impl.portal.desktop.wlr'
+dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.portal.Desktop'
+dbus-daemon[6658]: Activating service name='org.a11y.atspi.Registry' requested by ':1.0' (uid=1000 pid=6637 comm="waybar")
+dbus-daemon[6658]: Successfully activated service 'org.a11y.atspi.Registry'
+
+** (waybar:6637): WARNING **: 20:24:14.761: gtk-layer-shell v0.7.0 may not work on GTK v3.24.34. If you experience crashes, check https://github.com/wmww/gtk-layer-shell/blob/master/compatibility.md
+M 20:24:30.692356        wireplumber ../src/main.c:360:on_disconnected: disconnected from pipewire
diff --git a/list.c b/list.c
new file mode 100644
index 00000000..bb9ec712
--- /dev/null
+++ b/list.c
@@ -0,0 +1,159 @@
+#include "list.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+list_t *create_list(void) {
+	list_t *list = malloc(sizeof(list_t));
+	if (!list) {
+		return NULL;
+	}
+	list->capacity = 10;
+	list->length = 0;
+	list->items = malloc(sizeof(void*) * list->capacity);
+	return list;
+}
+
+static void list_resize(list_t *list) {
+	if (list->length == list->capacity) {
+		list->capacity *= 2;
+		list->items = realloc(list->items, sizeof(void*) * list->capacity);
+	}
+}
+
+void list_free(list_t *list) {
+	if (list == NULL) {
+		return;
+	}
+	free(list->items);
+	free(list);
+}
+
+void list_add(list_t *list, void *item) {
+	list_resize(list);
+	list->items[list->length++] = item;
+}
+
+void list_insert(list_t *list, int index, void *item) {
+	list_resize(list);
+	memmove(&list->items[index + 1], &list->items[index], sizeof(void*) * (list->length - index));
+	list->length++;
+	list->items[index] = item;
+}
+
+void list_del(list_t *list, int index) {
+	list->length--;
+	memmove(&list->items[index], &list->items[index + 1], sizeof(void*) * (list->length - index));
+}
+
+void list_cat(list_t *list, list_t *source) {
+	for (int i = 0; i < source->length; ++i) {
+		list_add(list, source->items[i]);
+	}
+}
+
+void list_qsort(list_t *list, int compare(const void *left, const void *right)) {
+	qsort(list->items, list->length, sizeof(void *), compare);
+}
+
+int list_seq_find(list_t *list, int compare(const void *item, const void *data), const void *data) {
+	for (int i = 0; i < list->length; i++) {
+		void *item = list->items[i];
+		if (compare(item, data) == 0) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+int list_find(list_t *list, const void *item) {
+	for (int i = 0; i < list->length; i++) {
+		if (list->items[i] == item) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+void list_swap(list_t *list, int src, int dest) {
+	void *tmp = list->items[src];
+	list->items[src] = list->items[dest];
+	list->items[dest] = tmp;
+}
+
+void list_move_to_end(list_t *list, void *item) {
+	int i;
+	for (i = 0; i < list->length; ++i) {
+		if (list->items[i] == item) {
+			break;
+		}
+	}
+	if (!(i < list->length)) {
+		return;
+	}
+	list_del(list, i);
+	list_add(list, item);
+}
+
+static void list_rotate(list_t *list, int from, int to) {
+	void *tmp = list->items[to];
+
+	while (to > from) {
+		list->items[to] = list->items[to - 1];
+		to--;
+	}
+
+	list->items[from] = tmp;
+}
+
+static void list_inplace_merge(list_t *list, int left, int last, int mid, int compare(const void *a, const void *b)) {
+	int right = mid + 1;
+
+	if (compare(&list->items[mid], &list->items[right]) <= 0) {
+		return;
+	}
+
+	while (left <= mid && right <= last) {
+		if (compare(&list->items[left], &list->items[right]) <= 0) {
+			left++;
+		} else {
+			list_rotate(list, left, right);
+			left++;
+			mid++;
+			right++;
+		}
+	}
+}
+
+static void list_inplace_sort(list_t *list, int first, int last, int compare(const void *a, const void *b)) {
+	if (first >= last) {
+		return;
+	} else if ((last - first) == 1) {
+		if (compare(&list->items[first], &list->items[last]) > 0) {
+			list_swap(list, first, last);
+		}
+	} else {
+		int mid = (int)((last + first) / 2);
+		list_inplace_sort(list, first, mid, compare);
+		list_inplace_sort(list, mid + 1, last, compare);
+		list_inplace_merge(list, first, last, mid, compare);
+	}
+}
+
+void list_stable_sort(list_t *list, int compare(const void *a, const void *b)) {
+	if (list->length > 1) {
+		list_inplace_sort(list, 0, list->length - 1, compare);
+	}
+}
+
+void list_free_items_and_destroy(list_t *list) {
+	if (!list) {
+		return;
+	}
+
+	for (int i = 0; i < list->length; ++i) {
+		free(list->items[i]);
+	}
+	list_free(list);
+}
+
diff --git a/list.h b/list.h
new file mode 100644
index 00000000..895f6cc0
--- /dev/null
+++ b/list.h
@@ -0,0 +1,35 @@
+#ifndef _SWAY_LIST_H
+#define _SWAY_LIST_H
+
+typedef struct {
+	int capacity;
+	int length;
+	void **items;
+} list_t;
+
+list_t *create_list(void);
+void list_free(list_t *list);
+void list_add(list_t *list, void *item);
+void list_insert(list_t *list, int index, void *item);
+void list_del(list_t *list, int index);
+void list_cat(list_t *list, list_t *source);
+// See qsort. Remember to use *_qsort functions as compare functions,
+// because they dereference the left and right arguments first!
+void list_qsort(list_t *list, int compare(const void *left, const void *right));
+// Return index for first item in list that returns 0 for given compare
+// function or -1 if none matches.
+int list_seq_find(list_t *list, int compare(const void *item, const void *cmp_to), const void *cmp_to);
+int list_find(list_t *list, const void *item);
+// stable sort since qsort is not guaranteed to be stable
+void list_stable_sort(list_t *list, int compare(const void *a, const void *b));
+// swap two elements in a list
+void list_swap(list_t *list, int src, int dest);
+// move item to end of list
+void list_move_to_end(list_t *list, void *item);
+
+/* Calls `free` for each item in the list, then frees the list.
+ * Do not use this to free lists of primitives or items that require more
+ * complicated deallocation code.
+ */
+void list_free_items_and_destroy(list_t *list);
+#endif
diff --git a/stringop.c b/stringop.c
new file mode 100644
index 00000000..23c4b96f
--- /dev/null
+++ b/stringop.c
@@ -0,0 +1,331 @@
+#define _POSIX_C_SOURCE 200809L
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <wordexp.h>
+#include <wordexp.h>
+#include "list.h"
+
+static const char whitespace[] = " \f\n\r\t\v";
+
+void strip_whitespace(char *str) {
+	size_t len = strlen(str);
+	size_t start = strspn(str, whitespace);
+	memmove(str, &str[start], len + 1 - start);
+
+	if (*str) {
+		for (len -= start + 1; isspace(str[len]); --len) {}
+		str[len + 1] = '\0';
+	}
+}
+
+void strip_quotes(char *str) {
+	bool in_str = false;
+	bool in_chr = false;
+	bool escaped = false;
+	char *end = strchr(str,0);
+	while (*str) {
+		if (*str == '\'' && !in_str && !escaped) {
+			in_chr = !in_chr;
+			goto shift_over;
+		} else if (*str == '\"' && !in_chr && !escaped) {
+			in_str = !in_str;
+			goto shift_over;
+		} else if (*str == '\\') {
+			escaped = !escaped;
+			++str;
+			continue;
+		}
+		escaped = false;
+		++str;
+		continue;
+		shift_over:
+		memmove(str, str+1, end-- - str);
+	}
+	*end = '\0';
+}
+
+char *lenient_strcat(char *dest, const char *src) {
+	if (dest && src) {
+		return strcat(dest, src);
+	}
+	return dest;
+}
+
+char *lenient_strncat(char *dest, const char *src, size_t len) {
+	if (dest && src) {
+		return strncat(dest, src, len);
+	}
+	return dest;
+}
+
+// strcmp that also handles null pointers.
+int lenient_strcmp(const char *a, const char *b) {
+	if (a == b) {
+		return 0;
+	} else if (!a) {
+		return -1;
+	} else if (!b) {
+		return 1;
+	} else {
+		return strcmp(a, b);
+	}
+}
+
+list_t *split_string(const char *str, const char *delims) {
+	list_t *res = create_list();
+	char *copy = strdup(str);
+
+	char *token = strtok(copy, delims);
+	while (token) {
+		list_add(res, strdup(token));
+		token = strtok(NULL, delims);
+	}
+	free(copy);
+	return res;
+}
+
+char **split_args(const char *start, int *argc) {
+	int alloc = 2;
+	char **argv = malloc(sizeof(char *) * alloc);
+	bool in_token = false;
+	bool in_string = false;
+	bool in_char = false;
+	bool in_brackets = false; // brackets are used for criteria
+	bool escaped = false;
+	const char *end = start;
+	*argc = 0;
+	if (start) {
+		while (*start) {
+			if (!in_token) {
+				start = (end += strspn(end, whitespace));
+				in_token = true;
+			}
+			if (*end == '"' && !in_char && !escaped) {
+				in_string = !in_string;
+			} else if (*end == '\'' && !in_string && !escaped) {
+				in_char = !in_char;
+			} else if (*end == '[' && !in_string && !in_char && !in_brackets && !escaped) {
+				in_brackets = true;
+			} else if (*end == ']' && !in_string && !in_char && in_brackets && !escaped) {
+				in_brackets = false;
+			} else if (*end == '\\') {
+				escaped = !escaped;
+			} else if (*end == '\0' || (!in_string && !in_char && !in_brackets
+						&& !escaped && strchr(whitespace, *end))) {
+				goto add_token;
+			}
+			if (*end != '\\') {
+				escaped = false;
+			}
+			++end;
+			continue;
+			add_token:
+			if (end - start > 0) {
+				char *token = malloc(end - start + 1);
+				strncpy(token, start, end - start + 1);
+				token[end - start] = '\0';
+				argv[*argc] = token;
+				if (++*argc + 1 == alloc) {
+					argv = realloc(argv, (alloc *= 2) * sizeof(char *));
+				}
+			}
+			in_token = false;
+			escaped = false;
+		}
+	}
+	argv[*argc] = NULL;
+	return argv;
+}
+
+void free_argv(int argc, char **argv) {
+	while (argc-- > 0) {
+		free(argv[argc]);
+	}
+	free(argv);
+}
+
+int unescape_string(char *string) {
+	/* TODO: More C string escapes */
+	int len = strlen(string);
+	int shift = 0;
+	int i;
+	for (i = 0; string[i]; ++i) {
+		if (string[i] == '\\') {
+			switch (string[++i]) {
+			case '0':
+				string[i - 1] = '\0';
+				return i - 1;
+			case 'a':
+				string[i - 1] = '\a';
+				string[i] = '\0';
+				break;
+			case 'b':
+				string[i - 1] = '\b';
+				string[i] = '\0';
+				break;
+			case 'f':
+				string[i - 1] = '\f';
+				string[i] = '\0';
+				break;
+			case 'n':
+				string[i - 1] = '\n';
+				string[i] = '\0';
+				break;
+			case 'r':
+				string[i - 1] = '\r';
+				string[i] = '\0';
+				break;
+			case 't':
+				string[i - 1] = '\t';
+				string[i] = '\0';
+				break;
+			case 'v':
+				string[i - 1] = '\v';
+				string[i] = '\0';
+				break;
+			case '\\':
+				string[i] = '\0';
+				break;
+			case '\'':
+				string[i - 1] = '\'';
+				string[i] = '\0';
+				break;
+			case '\"':
+				string[i - 1] = '\"';
+				string[i] = '\0';
+				break;
+			case '?':
+				string[i - 1] = '?';
+				string[i] = '\0';
+				break;
+			case 'x':
+				{
+					unsigned char c = 0;
+					if (string[i+1] >= '0' && string[i+1] <= '9') {
+						c = string[i+1] - '0';
+						if (string[i+2] >= '0' && string[i+2] <= '9') {
+							c *= 0x10;
+							c += string[i+2] - '0';
+							string[i+2] = '\0';
+						}
+						string[i+1] = '\0';
+					}
+					string[i] = '\0';
+					string[i - 1] = c;
+				}
+			}
+		}
+	}
+	// Shift characters over nullspaces
+	for (i = 0; i < len; ++i) {
+		if (string[i] == 0) {
+			shift++;
+			continue;
+		}
+		string[i-shift] = string[i];
+	}
+	string[len - shift] = 0;
+	return len - shift;
+}
+
+char *join_args(char **argv, int argc) {
+	int len = 0, i;
+	char *res;
+	if (argc < 0) {
+		return NULL;
+	}
+	for (i = 0; i < argc; ++i) {
+		len += strlen(argv[i]) + 1;
+	}
+	res = malloc(len);
+	len = 0;
+	for (i = 0; i < argc; ++i) {
+		strcpy(res + len, argv[i]);
+		len += strlen(argv[i]);
+		res[len++] = ' ';
+	}
+	res[len - 1] = '\0';
+	return res;
+}
+
+static inline char *argsep_next_interesting(const char *src, const char *delim) {
+	char *special = strpbrk(src, "\"'\\");
+	char *next_delim = strpbrk(src, delim);
+	if (!special) {
+		return next_delim;
+	}
+	if (!next_delim) {
+		return special;
+	}
+	return (next_delim < special) ? next_delim : special;
+}
+
+char *argsep(char **stringp, const char *delim, char *matched) {
+	char *start = *stringp;
+	char *end = start;
+	bool in_string = false;
+	bool in_char = false;
+	bool escaped = false;
+	char *interesting = NULL;
+
+	while ((interesting = argsep_next_interesting(end, delim))) {
+		if (escaped && interesting != end) {
+			escaped = false;
+		}
+		if (*interesting == '"' && !in_char && !escaped) {
+			in_string = !in_string;
+			end = interesting + 1;
+		} else if (*interesting == '\'' && !in_string && !escaped) {
+			in_char = !in_char;
+			end = interesting + 1;
+		} else if (*interesting == '\\') {
+			escaped = !escaped;
+			end = interesting + 1;
+		} else if (!in_string && !in_char && !escaped) {
+			// We must have matched a separator
+			end = interesting;
+			if (matched) {
+				*matched = *end;
+			}
+			if (end - start) {
+				*(end++) = 0;
+				*stringp = end;
+				break;
+			} else {
+				end = ++start;
+			}
+		} else {
+			end++;
+		}
+	}
+	if (!interesting) {
+		*stringp = NULL;
+		if (matched) {
+			*matched = '\0';
+		}
+	}
+	return start;
+}
+
+bool expand_path(char **path) {
+	char *ptr;
+	wordexp_t p = {0};
+	while (strstr(*path, "  ")) {
+		*path = realloc(*path, strlen(*path) + 2);
+		ptr = strstr(*path, "  ") + 1;
+		memmove(ptr + 1, ptr, strlen(ptr) + 1);
+		*ptr = '\\';
+	}
+	if (wordexp(*path, &p, 0) != 0 || p.we_wordv[0] == NULL) {
+		wordfree(&p);
+		return false;
+	}
+	free(*path);
+	*path = join_args(p.we_wordv, p.we_wordc);
+	wordfree(&p);
+	return true;
+}
diff --git a/stringop.h b/stringop.h
new file mode 100644
index 00000000..4ca950d3
--- /dev/null
+++ b/stringop.h
@@ -0,0 +1,30 @@
+#ifndef _SWAY_STRINGOP_H
+#define _SWAY_STRINGOP_H
+
+void strip_whitespace(char *str);
+void strip_quotes(char *str);
+
+// strcat that does nothing if dest or src is NULL
+char *lenient_strcat(char *dest, const char *src);
+char *lenient_strncat(char *dest, const char *src, size_t len);
+
+// strcmp that also handles null pointers.
+int lenient_strcmp(const char *a, const char *b);
+
+// Simply split a string with delims, free with `list_free_items_and_destroy`
+list_t *split_string(const char *str, const char *delims);
+
+// Splits an argument string, keeping quotes intact
+char **split_args(const char *str, int *argc);
+void free_argv(int argc, char **argv);
+
+int unescape_string(char *string);
+char *join_args(char **argv, int argc);
+
+// Split string into 2 by delim, handle quotes
+char *argsep(char **stringp, const char *delim, char *matched_delim);
+
+// Expand a path using shell replacements such as $HOME and ~
+bool expand_path(char **path);
+
+#endif

From 9a2962a567b55521294f188ce6feb6cd6dd09a4e Mon Sep 17 00:00:00 2001
From: Isaac Mills <rooster0055@protonmail.com>
Date: Wed, 8 Jun 2022 21:50:53 -0400
Subject: [PATCH 2/2] Fix config.mk

---
 0001-For-patching.patch | 2910 +++++++++++++++++++++++++++++++++++++++
 config.mk               |    1 -
 2 files changed, 2910 insertions(+), 1 deletion(-)
 create mode 100644 0001-For-patching.patch

diff --git a/0001-For-patching.patch b/0001-For-patching.patch
new file mode 100644
index 00000000..df1ef6d1
--- /dev/null
+++ b/0001-For-patching.patch
@@ -0,0 +1,2910 @@
+From 6b785ee303e0df40da90cc4ec5910ce9830d355a Mon Sep 17 00:00:00 2001
+From: Isaac Mills <rooster0055@protonmail.com>
+Date: Wed, 8 Jun 2022 21:36:05 -0400
+Subject: [PATCH] For patching
+
+---
+ Makefile     |    8 +-
+ commands.c   |  541 +++++++++++++++++++++++
+ commands.h   |  307 +++++++++++++
+ config.def.h |    6 +-
+ config.mk    |    1 +
+ dwl.c        | 1204 +++++++++++++++++++++++++++++++++++++++++++++++++-
+ hmm.log      |   24 +
+ list.c       |  159 +++++++
+ list.h       |   35 ++
+ stringop.c   |  331 ++++++++++++++
+ stringop.h   |   30 ++
+ 11 files changed, 2634 insertions(+), 12 deletions(-)
+ create mode 100644 commands.c
+ create mode 100644 commands.h
+ create mode 100644 hmm.log
+ create mode 100644 list.c
+ create mode 100644 list.h
+ create mode 100644 stringop.c
+ create mode 100644 stringop.h
+
+diff --git a/Makefile b/Makefile
+index 59b2519..f3a478f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -11,7 +11,7 @@ WAYLAND_PROTOCOLS = `pkg-config --variable=pkgdatadir wayland-protocols`
+ WAYLAND_SCANNER   = `pkg-config --variable=wayland_scanner wayland-scanner`
+ 
+ # CFLAGS / LDFLAGS
+-PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
++PKGS      = wlroots wayland-server xkbcommon libinput json-c $(XLIBS)
+ DWLCFLAGS = `pkg-config --cflags $(PKGS)` $(DWLCPPFLAGS) $(CFLAGS) $(XWAYLAND)
+ LDLIBS    = `pkg-config --libs $(PKGS)`
+ 
+@@ -21,10 +21,12 @@ LDLIBS    = `pkg-config --libs $(PKGS)`
+ # protocols, which are specified in XML. wlroots requires you to rig these up
+ # to your build system yourself and provide them in the include path.
+ all: dwl
+-dwl: dwl.o util.o
+-	$(CC) $(LDLIBS) $(LDFLAGS) -o $@ dwl.o util.o
++dwl: dwl.o util.o list.o stringop.o
++	$(CC) $(LDLIBS) $(LDFLAGS) -o $@ dwl.o util.o list.o stringop.o
+ dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+ util.o: util.c util.h
++list.o: list.c list.h
++stringop.o: stringop.c stringop.h
+ 
+ # wayland scanner rules to generate .h / .c files
+ xdg-shell-protocol.h:
+diff --git a/commands.c b/commands.c
+new file mode 100644
+index 0000000..a25e386
+--- /dev/null
++++ b/commands.c
+@@ -0,0 +1,541 @@
++#include "commands.h"
++
++// Returns error object, or NULL if check succeeds.
++struct cmd_results *checkarg(int argc, const char *name, enum expected_args type, int val) {
++	const char *error_name = NULL;
++	switch (type) {
++	case EXPECTED_AT_LEAST:
++		if (argc < val) {
++			error_name = "at least ";
++		}
++		break;
++	case EXPECTED_AT_MOST:
++		if (argc > val) {
++			error_name = "at most ";
++		}
++		break;
++	case EXPECTED_EQUAL_TO:
++		if (argc != val) {
++			error_name = "";
++		}
++	}
++	return error_name ?
++		cmd_results_new(CMD_INVALID, "Invalid %s command "
++				"(expected %s%d argument%s, got %d)",
++				name, error_name, val, val != 1 ? "s" : "", argc)
++		: NULL;
++}
++
++/* Keep alphabetized */
++static const struct cmd_handler handlers[] = {
++	{ "assign", NULL },
++	{ "bar", NULL },
++	{ "bindcode", NULL },
++	{ "bindgesture", NULL },
++	{ "bindswitch", NULL },
++	{ "bindsym", NULL },
++	{ "client.background", NULL },
++	{ "client.focused", NULL },
++	{ "client.focused_inactive", NULL },
++	{ "client.focused_tab_title", NULL },
++	{ "client.placeholder", NULL },
++	{ "client.unfocused", NULL },
++	{ "client.urgent", NULL },
++	{ "default_border", NULL },
++	{ "default_floating_border", NULL },
++	{ "exec", NULL },
++	{ "exec_always", NULL },
++	{ "floating_maximum_size", NULL },
++	{ "floating_minimum_size", NULL },
++	{ "floating_modifier", NULL },
++	{ "focus", NULL },
++	{ "focus_follows_mouse", NULL },
++	{ "focus_on_window_activation", NULL },
++	{ "focus_wrapping", NULL },
++	{ "font", NULL },
++	{ "for_window", NULL },
++	{ "force_display_urgency_hint", NULL },
++	{ "force_focus_wrapping", NULL },
++	{ "fullscreen", NULL },
++	{ "gaps", NULL },
++	{ "hide_edge_borders", NULL },
++	{ "input", NULL },
++	{ "mode", NULL },
++	{ "mouse_warping", NULL },
++	{ "new_float", NULL },
++	{ "new_window", NULL },
++	{ "no_focus", NULL },
++	{ "output", NULL },
++	{ "popup_during_fullscreen", NULL },
++	{ "seat", NULL },
++	{ "set", NULL },
++	{ "show_marks", NULL },
++	{ "smart_borders", NULL },
++	{ "smart_gaps", NULL },
++	{ "tiling_drag", NULL },
++	{ "tiling_drag_threshold", NULL },
++	{ "title_align", NULL },
++	{ "titlebar_border_thickness", NULL },
++	{ "titlebar_padding", NULL },
++	{ "unbindcode", NULL },
++	{ "unbindgesture", NULL },
++	{ "unbindswitch", NULL },
++	{ "unbindsym", NULL },
++	{ "workspace", cmd_workspace },
++	{ "workspace_auto_back_and_forth", NULL },
++};
++
++/* Runtime-only commands. Keep alphabetized */
++static const struct cmd_handler command_handlers[] = {
++	{ "border", NULL },
++	{ "create_output", NULL },
++	{ "exit", NULL },
++	{ "floating", NULL },
++	{ "fullscreen", NULL },
++	{ "inhibit_idle", NULL },
++	{ "kill", NULL },
++	{ "layout", NULL },
++	{ "mark", NULL },
++	{ "max_render_time", NULL },
++	{ "move", NULL },
++	{ "nop", NULL },
++	{ "opacity", NULL },
++	{ "reload", NULL },
++	{ "rename", NULL },
++	{ "resize", NULL },
++	{ "scratchpad", NULL },
++	{ "shortcuts_inhibitor", NULL },
++	{ "split", NULL },
++	{ "splith", NULL },
++	{ "splitt", NULL },
++	{ "splitv", NULL },
++	{ "sticky", NULL },
++	{ "swap", NULL },
++	{ "title_format", NULL },
++	{ "unmark", NULL },
++	{ "urgent", NULL },
++};
++
++static int handler_compare(const void *_a, const void *_b) {
++	const struct cmd_handler *a = _a;
++	const struct cmd_handler *b = _b;
++	return strcasecmp(a->command, b->command);
++}
++
++const struct cmd_handler *find_handler(char *line,
++		const struct cmd_handler *handlers, size_t handlers_size) {
++	const struct cmd_handler query = { .command = line };
++	if (!handlers || !handlers_size) {
++		return NULL;
++	}
++	return bsearch(&query, handlers,
++			handlers_size / sizeof(struct cmd_handler),
++			sizeof(struct cmd_handler), handler_compare);
++}
++
++static const struct cmd_handler *find_handler_ex(char *line,
++		// const struct cmd_handler *command_handlers, size_t command_handlers_size,
++		const struct cmd_handler *handlers, size_t handlers_size) {
++	/*
++	const struct cmd_handler *handler = NULL;
++		handler = find_handler(line, command_handlers, command_handlers_size);
++	return handler ? handler : find_handler(line, handlers, handlers_size);
++	*/
++	return find_handler(line, handlers, handlers_size);
++}
++
++static const struct cmd_handler *find_core_handler(char *line) {
++	return find_handler_ex(line, 
++			//command_handlers, sizeof(command_handlers),
++			handlers, sizeof(handlers)
++	);
++}
++
++char *do_var_replacement(char *str) {
++	int i;
++	char *find = str;
++	while ((find = strchr(find, '$'))) {
++		// Skip if escaped.
++		if (find > str && find[-1] == '\\') {
++			if (find == str + 1 || !(find > str + 1 && find[-2] == '\\')) {
++				++find;
++				continue;
++			}
++		}
++		// Unescape double $ and move on
++		if (find[1] == '$') {
++			size_t length = strlen(find + 1);
++			memmove(find, find + 1, length);
++			find[length] = '\0';
++			++find;
++			continue;
++		}
++		// Find matching variable
++		/*
++		for (i = 0; i < config->symbols->length; ++i) {
++			struct sway_variable *var = config->symbols->items[i];
++			int vnlen = strlen(var->name);
++			if (strncmp(find, var->name, vnlen) == 0) {
++				int vvlen = strlen(var->value);
++				char *newstr = malloc(strlen(str) - vnlen + vvlen + 1);
++				if (!newstr) {
++					fprintf(stderr,
++						"Unable to allocate replacement "
++						"during variable expansion");
++					break;
++				}
++				char *newptr = newstr;
++				int offset = find - str;
++				strncpy(newptr, str, offset);
++				newptr += offset;
++				strncpy(newptr, var->value, vvlen);
++				newptr += vvlen;
++				strcpy(newptr, find + vnlen);
++				free(str);
++				str = newstr;
++				find = str + offset + vvlen;
++				break;
++			}
++		}
++		if (i == config->symbols->length) {
++			++find;
++		}
++		*/
++	}
++	return str;
++}
++
++list_t *execute_command(char *_exec, Client *con) {
++	char *cmd;
++	char *error;
++	char matched_delim = ';';
++	list_t *containers = NULL;
++	bool using_criteria = false;
++
++	char *exec = strdup(_exec);
++	char *head = exec;
++	list_t *res_list = create_list();
++	struct criteria *criteria;
++
++	int i;
++	int argc;
++	char **argv;
++	const struct cmd_handler *handler;
++	struct cmd_results *fail_res;
++	struct sway_container *container;
++
++	struct cmd_results *res;
++	if (!res_list || !exec) {
++		return NULL;
++	}
++
++	do {
++		for (; isspace(*head); ++head) {}
++		// Extract criteria (valid for this command list only).
++		/*
++		if (matched_delim == ';') {
++			using_criteria = false;
++			if (*head == '[') {
++				error = NULL;
++				criteria = criteria_parse(head, &error);
++				if (!criteria) {
++					list_add(res_list,
++							cmd_results_new(CMD_INVALID, "%s", error));
++					free(error);
++					goto cleanup;
++				}
++				list_free(containers);
++				containers = criteria_get_containers(criteria);
++				head += strlen(criteria->raw);
++				criteria_destroy(criteria);
++				using_criteria = true;
++				// Skip leading whitespace
++				for (; isspace(*head); ++head) {}
++			}
++		}
++		*/
++		// Split command list
++		cmd = argsep(&head, ";,", &matched_delim);
++		for (; isspace(*cmd); ++cmd) {}
++
++		if (strcmp(cmd, "") == 0) {
++			fprintf(stderr, "Ignoring empty command.");
++			continue;
++		}
++		fprintf(stderr, "Handling command '%s'", cmd);
++		//TODO better handling of argv
++		argv = split_args(cmd, &argc);
++		if (strcmp(argv[0], "exec") != 0 &&
++				strcmp(argv[0], "exec_always") != 0 &&
++				strcmp(argv[0], "mode") != 0) {
++			for (i = 1; i < argc; ++i) {
++				if (*argv[i] == '\"' || *argv[i] == '\'') {
++					strip_quotes(argv[i]);
++				}
++			}
++		}
++		handler = find_core_handler(argv[0]);
++		if (!handler) {
++			list_add(res_list, cmd_results_new(CMD_INVALID,
++					"Unknown/invalid command '%s'", argv[0]));
++			free_argv(argc, argv);
++			goto cleanup;
++		}
++
++		// Var replacement, for all but first argument of set
++		for (i = 1; i < argc; ++i) {
++			argv[i] = do_var_replacement(argv[i]);
++		}
++
++
++		/*
++		if (!using_criteria) {
++			if (con) {
++				set_config_node(&con->node, true);
++			} else {
++				set_config_node(seat_get_focus_inactive(seat, &root->node),
++						false);
++			}
++			res = handler->handle(argc-1, argv+1);
++			list_add(res_list, res);
++			if (res->status == CMD_INVALID) {
++				free_argv(argc, argv);
++				goto cleanup;
++			}
++		} else if (containers->length == 0) {
++			list_add(res_list,
++					cmd_results_new(CMD_FAILURE, "No matching node."));
++		} else {
++		*/
++			fail_res = NULL;
++			res = handler->handle(argc-1, argv+1);
++			if (res->status == CMD_SUCCESS) {
++				free_cmd_results(res);
++			} else {
++				// last failure will take precedence
++				if (fail_res) {
++					free_cmd_results(fail_res);
++				}
++				fail_res = res;
++				if (res->status == CMD_INVALID) {
++					list_add(res_list, fail_res);
++					free_argv(argc, argv);
++					goto cleanup;
++				}
++			}
++			list_add(res_list,
++					fail_res ? fail_res : cmd_results_new(CMD_SUCCESS, NULL));
++		//}
++		free_argv(argc, argv);
++	} while(head);
++cleanup:
++	free(exec);
++	list_free(containers);
++	return res_list;
++}
++
++// this is like execute_command above, except:
++// 1) it ignores empty commands (empty lines)
++// 2) it does variable substitution
++// 3) it doesn't split commands (because the multiple commands are supposed to
++//	  be chained together)
++// 4) execute_command handles all state internally while config_command has
++// some state handled outside (notably the block mode, in read_config)
++struct cmd_results *config_command(char *exec, char **new_block) {
++	struct cmd_results *results = NULL;
++	int argc, i;
++	char **argv = split_args(exec, &argc);
++	char *temp;
++	const struct cmd_handler *handler;
++	const char *error;
++	char *command;
++
++	// Check for empty lines
++	if (!argc) {
++		results = cmd_results_new(CMD_SUCCESS, NULL);
++		goto cleanup;
++	}
++
++	// Check for the start of a block
++	if (argc > 1 && strcmp(argv[argc - 1], "{") == 0) {
++		*new_block = join_args(argv, argc - 1);
++		results = cmd_results_new(CMD_BLOCK, NULL);
++		goto cleanup;
++	}
++
++	// Check for the end of a block
++	if (strcmp(argv[argc - 1], "}") == 0) {
++		results = cmd_results_new(CMD_BLOCK_END, NULL);
++		goto cleanup;
++	}
++
++	// Make sure the command is not stored in a variable
++	if (*argv[0] == '$') {
++		argv[0] = do_var_replacement(argv[0]);
++		temp = join_args(argv, argc);
++		free_argv(argc, argv);
++		argv = split_args(temp, &argc);
++		free(temp);
++		if (!argc) {
++			results = cmd_results_new(CMD_SUCCESS, NULL);
++			goto cleanup;
++		}
++	}
++
++	// Determine the command handler
++	fprintf(stderr, "Config command: %s", exec);
++	handler = find_core_handler(argv[0]);
++	if (!handler || !handler->handle) {
++		error = handler
++			? "Command '%s' is shimmed, but unimplemented"
++			: "Unknown/invalid command '%s'";
++		results = cmd_results_new(CMD_INVALID, error, argv[0]);
++		goto cleanup;
++	}
++
++	/*
++	// Do variable replacement
++	if (handler->handle == cmd_set && argc > 1 && *argv[1] == '$') {
++		// Escape the variable name so it does not get replaced by one shorter
++		char *temp = calloc(1, strlen(argv[1]) + 2);
++		temp[0] = '$';
++		strcpy(&temp[1], argv[1]);
++		free(argv[1]);
++		argv[1] = temp;
++	}
++	*/
++	command = do_var_replacement(join_args(argv, argc));
++	// fprintf(stderr, "After replacement: %s", command);
++	free_argv(argc, argv);
++	argv = split_args(command, &argc);
++	free(command);
++
++	// Strip quotes and unescape the string
++	for (i = 1; i < argc; ++i) {
++		/*
++		if (handler->handle != cmd_exec && handler->handle != cmd_exec_always
++				&& handler->handle != cmd_mode
++				&& handler->handle != cmd_bindsym
++				&& handler->handle != cmd_bindcode
++				&& handler->handle != cmd_bindswitch
++				&& handler->handle != cmd_bindgesture
++				&& handler->handle != cmd_set
++				&& handler->handle != cmd_for_window
++				&& (*argv[i] == '\"' || *argv[i] == '\'')) {
++				*/
++			strip_quotes(argv[i]);
++		//}
++		unescape_string(argv[i]);
++	}
++
++	// Run command
++	results = handler->handle(argc - 1, argv + 1);
++
++cleanup:
++	free_argv(argc, argv);
++	return results;
++}
++
++struct cmd_results *config_subcommand(char **argv, int argc,
++		const struct cmd_handler *handlers, size_t handlers_size) {
++	char *command = join_args(argv, argc);
++
++	const struct cmd_handler *handler = find_handler(argv[0], handlers,
++			handlers_size);
++	fprintf(stderr, "Subcommand: %s", command);
++	free(command);
++	if (!handler) {
++		return cmd_results_new(CMD_INVALID,
++				"Unknown/invalid command '%s'", argv[0]);
++	}
++	if (handler->handle) {
++		return handler->handle(argc - 1, argv + 1);
++	}
++	return cmd_results_new(CMD_INVALID,
++			"The command '%s' is shimmed, but unimplemented", argv[0]);
++}
++
++struct cmd_results *config_commands_command(char *exec) {
++	struct cmd_results *results = NULL;
++	int argc;
++	char **argv = split_args(exec, &argc);
++	char *cmd = argv[0];
++	const struct cmd_handler *handler;
++	if (!argc) {
++		results = cmd_results_new(CMD_SUCCESS, NULL);
++		goto cleanup;
++	}
++
++	// Find handler for the command this is setting a policy for
++
++	if (strcmp(cmd, "}") == 0) {
++		results = cmd_results_new(CMD_BLOCK_END, NULL);
++		goto cleanup;
++	}
++
++	handler = find_handler(cmd, NULL, 0);
++	if (!handler && strcmp(cmd, "*") != 0) {
++		results = cmd_results_new(CMD_INVALID,
++			"Unknown/invalid command '%s'", cmd);
++		goto cleanup;
++	}
++
++	results = cmd_results_new(CMD_SUCCESS, NULL);
++
++cleanup:
++	free_argv(argc, argv);
++	return results;
++}
++
++struct cmd_results *cmd_results_new(enum cmd_status status,
++		const char *format, ...) {
++	struct cmd_results *results = malloc(sizeof(struct cmd_results));
++	if (!results) {
++		fprintf(stderr, "Unable to allocate command results");
++		return NULL;
++	}
++	results->status = status;
++	if (format) {
++		char *error = malloc(256);
++		va_list args;
++		va_start(args, format);
++		if (error) {
++			vsnprintf(error, 256, format, args);
++		}
++		va_end(args);
++		results->error = error;
++	} else {
++		results->error = NULL;
++	}
++	return results;
++}
++
++void free_cmd_results(struct cmd_results *results) {
++	if (results->error) {
++		free(results->error);
++	}
++	free(results);
++}
++
++char *cmd_results_to_json(list_t *res_list) {
++	const char *json;
++	char *res;
++	json_object *result_array = json_object_new_array();
++	for (int i = 0; i < res_list->length; ++i) {
++		struct cmd_results *results = res_list->items[i];
++		json_object *root = json_object_new_object();
++		json_object_object_add(root, "success",
++				json_object_new_boolean(results->status == CMD_SUCCESS));
++		if (results->error) {
++			json_object_object_add(root, "parse_error",
++					json_object_new_boolean(results->status == CMD_INVALID));
++			json_object_object_add(
++					root, "error", json_object_new_string(results->error));
++		}
++		json_object_array_add(result_array, root);
++	}
++	json = json_object_to_json_string(result_array);
++	res = strdup(json);
++	json_object_put(result_array);
++	return res;
++}
+diff --git a/commands.h b/commands.h
+new file mode 100644
+index 0000000..112c9d9
+--- /dev/null
++++ b/commands.h
+@@ -0,0 +1,307 @@
++#include <wlr/util/edges.h>
++
++typedef struct cmd_results *sway_cmd(int argc, char **argv);
++
++struct cmd_handler {
++	char *command;
++	sway_cmd *handle;
++};
++
++/**
++ * Indicates the result of a command's execution.
++ */
++enum cmd_status {
++	CMD_SUCCESS, 		/**< The command was successful */
++	CMD_FAILURE,		/**< The command resulted in an error */
++	CMD_INVALID, 		/**< Unknown command or parser error */
++	CMD_DEFER,		/**< Command execution deferred */
++	CMD_BLOCK,
++	CMD_BLOCK_COMMANDS,
++	CMD_BLOCK_END
++};
++
++/**
++ * Stores the result of executing a command.
++ */
++struct cmd_results {
++	enum cmd_status status;
++	/**
++	 * Human friendly error message, or NULL on success
++	 */
++	char *error;
++};
++
++enum expected_args {
++	EXPECTED_AT_LEAST,
++	EXPECTED_AT_MOST,
++	EXPECTED_EQUAL_TO
++};
++
++struct cmd_results *checkarg(int argc, const char *name,
++		enum expected_args type, int val);
++
++const struct cmd_handler *find_handler(char *line,
++		const struct cmd_handler *cmd_handlers, size_t handlers_size);
++
++/**
++ * Parse and executes a command.
++ *
++ * If the command string contains criteria then the command will be executed on
++ * all matching containers. Otherwise, it'll run on the `con` container. If
++ * `con` is NULL then it'll run on the currently focused container.
++ */
++list_t *execute_command(char *command, Client *c);
++/**
++ * Parse and handles a command during config file loading.
++ *
++ * Do not use this under normal conditions.
++ */
++struct cmd_results *config_command(char *command, char **new_block);
++/**
++ * Parse and handle a sub command
++ */
++struct cmd_results *config_subcommand(char **argv, int argc,
++		const struct cmd_handler *handlers, size_t handlers_size);
++/*
++ * Parses a command policy rule.
++ */
++struct cmd_results *config_commands_command(char *exec);
++/**
++ * Allocates a cmd_results object.
++ */
++struct cmd_results *cmd_results_new(enum cmd_status status, const char *error, ...);
++/**
++ * Frees a cmd_results object.
++ */
++void free_cmd_results(struct cmd_results *results);
++/**
++ * Serializes a list of cmd_results to a JSON string.
++ *
++ * Free the JSON string later on.
++ */
++char *cmd_results_to_json(list_t *res_list);
++
++/**
++ * TODO: Move this function and its dependent functions to container.c.
++ */
++void container_resize_tiled(Client *parent, uint32_t axis,
++		int amount);
++
++void container_find_resize_parent(Client *c,
++		uint32_t edge);
++
++/**
++ * Handlers shared by exec and exec_always.
++ */
++/*
++sway_cmd cmd_exec_validate;
++sway_cmd cmd_exec_process;
++
++sway_cmd cmd_assign;
++sway_cmd cmd_bar;
++sway_cmd cmd_bindcode;
++sway_cmd cmd_bindgesture;
++sway_cmd cmd_bindswitch;
++sway_cmd cmd_bindsym;
++sway_cmd cmd_border;
++sway_cmd cmd_client_noop;
++sway_cmd cmd_client_focused;
++sway_cmd cmd_client_focused_inactive;
++sway_cmd cmd_client_focused_tab_title;
++sway_cmd cmd_client_unfocused;
++sway_cmd cmd_client_urgent;
++sway_cmd cmd_client_placeholder;
++sway_cmd cmd_client_background;
++sway_cmd cmd_commands;
++sway_cmd cmd_create_output;
++sway_cmd cmd_default_border;
++sway_cmd cmd_default_floating_border;
++sway_cmd cmd_default_orientation;
++sway_cmd cmd_exec;
++sway_cmd cmd_exec_always;
++sway_cmd cmd_exit;
++sway_cmd cmd_floating;
++sway_cmd cmd_floating_maximum_size;
++sway_cmd cmd_floating_minimum_size;
++sway_cmd cmd_floating_modifier;
++sway_cmd cmd_floating_scroll;
++sway_cmd cmd_focus;
++sway_cmd cmd_focus_follows_mouse;
++sway_cmd cmd_focus_on_window_activation;
++sway_cmd cmd_focus_wrapping;
++sway_cmd cmd_font;
++sway_cmd cmd_for_window;
++sway_cmd cmd_force_display_urgency_hint;
++sway_cmd cmd_force_focus_wrapping;
++sway_cmd cmd_fullscreen;
++sway_cmd cmd_gaps;
++sway_cmd cmd_hide_edge_borders;
++sway_cmd cmd_include;
++sway_cmd cmd_inhibit_idle;
++sway_cmd cmd_input;
++sway_cmd cmd_seat;
++sway_cmd cmd_ipc;
++sway_cmd cmd_kill;
++sway_cmd cmd_layout;
++sway_cmd cmd_log_colors;
++sway_cmd cmd_mark;
++sway_cmd cmd_max_render_time;
++sway_cmd cmd_mode;
++sway_cmd cmd_mouse_warping;
++sway_cmd cmd_move;
++sway_cmd cmd_new_float;
++sway_cmd cmd_new_window;
++sway_cmd cmd_nop;
++sway_cmd cmd_opacity;
++sway_cmd cmd_new_float;
++sway_cmd cmd_new_window;
++sway_cmd cmd_no_focus;
++sway_cmd cmd_output;
++sway_cmd cmd_permit;
++sway_cmd cmd_popup_during_fullscreen;
++sway_cmd cmd_reject;
++sway_cmd cmd_reload;
++sway_cmd cmd_rename;
++sway_cmd cmd_resize;
++sway_cmd cmd_scratchpad;
++sway_cmd cmd_seamless_mouse;
++sway_cmd cmd_set;
++sway_cmd cmd_shortcuts_inhibitor;
++sway_cmd cmd_show_marks;
++sway_cmd cmd_smart_borders;
++sway_cmd cmd_smart_gaps;
++sway_cmd cmd_split;
++sway_cmd cmd_splith;
++sway_cmd cmd_splitt;
++sway_cmd cmd_splitv;
++sway_cmd cmd_sticky;
++sway_cmd cmd_swaybg_command;
++sway_cmd cmd_swaynag_command;
++sway_cmd cmd_swap;
++sway_cmd cmd_tiling_drag;
++sway_cmd cmd_tiling_drag_threshold;
++sway_cmd cmd_title_align;
++sway_cmd cmd_title_format;
++sway_cmd cmd_titlebar_border_thickness;
++sway_cmd cmd_titlebar_padding;
++sway_cmd cmd_unbindcode;
++sway_cmd cmd_unbindswitch;
++sway_cmd cmd_unbindgesture;
++sway_cmd cmd_unbindsym;
++sway_cmd cmd_unmark;
++sway_cmd cmd_urgent;
++*/
++sway_cmd cmd_workspace;
++/*
++sway_cmd cmd_workspace_layout;
++sway_cmd cmd_ws_auto_back_and_forth;
++sway_cmd cmd_xwayland;
++
++sway_cmd bar_cmd_bindcode;
++sway_cmd bar_cmd_binding_mode_indicator;
++sway_cmd bar_cmd_bindsym;
++sway_cmd bar_cmd_colors;
++sway_cmd bar_cmd_font;
++sway_cmd bar_cmd_gaps;
++sway_cmd bar_cmd_mode;
++sway_cmd bar_cmd_modifier;
++sway_cmd bar_cmd_output;
++sway_cmd bar_cmd_height;
++sway_cmd bar_cmd_hidden_state;
++sway_cmd bar_cmd_icon_theme;
++sway_cmd bar_cmd_id;
++sway_cmd bar_cmd_position;
++sway_cmd bar_cmd_separator_symbol;
++sway_cmd bar_cmd_status_command;
++sway_cmd bar_cmd_status_edge_padding;
++sway_cmd bar_cmd_status_padding;
++sway_cmd bar_cmd_pango_markup;
++sway_cmd bar_cmd_strip_workspace_numbers;
++sway_cmd bar_cmd_strip_workspace_name;
++sway_cmd bar_cmd_swaybar_command;
++sway_cmd bar_cmd_tray_bindcode;
++sway_cmd bar_cmd_tray_bindsym;
++sway_cmd bar_cmd_tray_output;
++sway_cmd bar_cmd_tray_padding;
++sway_cmd bar_cmd_unbindcode;
++sway_cmd bar_cmd_unbindsym;
++sway_cmd bar_cmd_wrap_scroll;
++sway_cmd bar_cmd_workspace_buttons;
++sway_cmd bar_cmd_workspace_min_width;
++
++sway_cmd bar_colors_cmd_active_workspace;
++sway_cmd bar_colors_cmd_background;
++sway_cmd bar_colors_cmd_focused_background;
++sway_cmd bar_colors_cmd_binding_mode;
++sway_cmd bar_colors_cmd_focused_workspace;
++sway_cmd bar_colors_cmd_inactive_workspace;
++sway_cmd bar_colors_cmd_separator;
++sway_cmd bar_colors_cmd_focused_separator;
++sway_cmd bar_colors_cmd_statusline;
++sway_cmd bar_colors_cmd_focused_statusline;
++sway_cmd bar_colors_cmd_urgent_workspace;
++
++sway_cmd input_cmd_seat;
++sway_cmd input_cmd_accel_profile;
++sway_cmd input_cmd_calibration_matrix;
++sway_cmd input_cmd_click_method;
++sway_cmd input_cmd_drag;
++sway_cmd input_cmd_drag_lock;
++sway_cmd input_cmd_dwt;
++sway_cmd input_cmd_events;
++sway_cmd input_cmd_left_handed;
++sway_cmd input_cmd_map_from_region;
++sway_cmd input_cmd_map_to_output;
++sway_cmd input_cmd_map_to_region;
++sway_cmd input_cmd_middle_emulation;
++sway_cmd input_cmd_natural_scroll;
++sway_cmd input_cmd_pointer_accel;
++sway_cmd input_cmd_scroll_factor;
++sway_cmd input_cmd_repeat_delay;
++sway_cmd input_cmd_repeat_rate;
++sway_cmd input_cmd_scroll_button;
++sway_cmd input_cmd_scroll_method;
++sway_cmd input_cmd_tap;
++sway_cmd input_cmd_tap_button_map;
++sway_cmd input_cmd_tool_mode;
++sway_cmd input_cmd_xkb_capslock;
++sway_cmd input_cmd_xkb_file;
++sway_cmd input_cmd_xkb_layout;
++sway_cmd input_cmd_xkb_model;
++sway_cmd input_cmd_xkb_numlock;
++sway_cmd input_cmd_xkb_options;
++sway_cmd input_cmd_xkb_rules;
++sway_cmd input_cmd_xkb_switch_layout;
++sway_cmd input_cmd_xkb_variant;
++
++sway_cmd output_cmd_adaptive_sync;
++sway_cmd output_cmd_background;
++sway_cmd output_cmd_disable;
++sway_cmd output_cmd_dpms;
++sway_cmd output_cmd_enable;
++sway_cmd output_cmd_max_render_time;
++sway_cmd output_cmd_mode;
++sway_cmd output_cmd_modeline;
++sway_cmd output_cmd_position;
++sway_cmd output_cmd_render_bit_depth;
++sway_cmd output_cmd_scale;
++sway_cmd output_cmd_scale_filter;
++sway_cmd output_cmd_subpixel;
++sway_cmd output_cmd_toggle;
++sway_cmd output_cmd_transform;
++
++sway_cmd seat_cmd_attach;
++sway_cmd seat_cmd_cursor;
++sway_cmd seat_cmd_fallback;
++sway_cmd seat_cmd_hide_cursor;
++sway_cmd seat_cmd_idle_inhibit;
++sway_cmd seat_cmd_idle_wake;
++sway_cmd seat_cmd_keyboard_grouping;
++sway_cmd seat_cmd_pointer_constraint;
++sway_cmd seat_cmd_shortcuts_inhibitor;
++sway_cmd seat_cmd_xcursor_theme;
++
++sway_cmd cmd_ipc_cmd;
++sway_cmd cmd_ipc_events;
++sway_cmd cmd_ipc_event_cmd;
++*/
+diff --git a/config.def.h b/config.def.h
+index 4f131dd..9621e67 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -78,8 +78,8 @@ static const double accel_speed = 0.0;
+ /* If you want to use the windows key change this to WLR_MODIFIER_LOGO */
+ #define MODKEY WLR_MODIFIER_ALT
+ #define TAGKEYS(KEY,SKEY,TAG) \
+-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
+-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
++	{ MODKEY,                    KEY,            view,            {.ui = TAG} }, \
++	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = TAG} }, \
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
+ 	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
+ 
+@@ -110,7 +110,7 @@ static const Key keys[] = {
+ 	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
+ 	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
+-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
++	{ MODKEY,                    XKB_KEY_0,          viewall,        {0} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
+ 	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
+ 	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
+diff --git a/config.mk b/config.mk
+index ba24bb8..330b564 100644
+--- a/config.mk
++++ b/config.mk
+@@ -6,6 +6,7 @@ PREFIX = /usr/local
+ MANDIR = $(PREFIX)/share/man
+ 
+ # Compile flags that can be used
++CFLAGS = -Ofast -march=native -flto
+ #CFLAGS = -pedantic -Wall -Wextra -Werror -Wno-unused-parameter -Wno-sign-compare -Wno-unused-function -Wno-unused-variable -Wno-unused-result -Wdeclaration-after-statement
+ 
+ XWAYLAND =
+diff --git a/dwl.c b/dwl.c
+index e4bed14..210d405 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -9,8 +9,15 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <sys/wait.h>
++#include <sys/un.h>
++#include <sys/socket.h>
++#include <sys/ioctl.h>
++#include <fcntl.h>
+ #include <time.h>
++#include <ctype.h>
++#include <strings.h>
+ #include <unistd.h>
++#include <json.h>
+ #include <wayland-server-core.h>
+ #include <wlr/backend.h>
+ #include <wlr/backend/libinput.h>
+@@ -54,6 +61,8 @@
+ #endif
+ 
+ #include "util.h"
++#include "list.h"
++#include "stringop.h"
+ 
+ /* macros */
+ #define MAX(A, B)               ((A) > (B) ? (A) : (B))
+@@ -201,7 +210,83 @@ typedef struct {
+ 	int monitor;
+ } Rule;
+ 
++#define event_mask(ev) (1 << (ev & 0x7F))
++
++enum ipc_command_type {
++	// i3 command types - see i3's I3_REPLY_TYPE constants
++	IPC_COMMAND = 0,
++	IPC_GET_WORKSPACES = 1,
++	IPC_SUBSCRIBE = 2,
++	IPC_GET_OUTPUTS = 3,
++	IPC_GET_TREE = 4,
++	IPC_GET_MARKS = 5,
++	IPC_GET_BAR_CONFIG = 6,
++	IPC_GET_VERSION = 7,
++	IPC_GET_BINDING_MODES = 8,
++	IPC_GET_CONFIG = 9,
++	IPC_SEND_TICK = 10,
++	IPC_SYNC = 11,
++	IPC_GET_BINDING_STATE = 12,
++
++	// sway-specific command types
++	IPC_GET_INPUTS = 100,
++	IPC_GET_SEATS = 101,
++
++	// Events sent from sway to clients. Events have the highest bits set.
++	IPC_EVENT_WORKSPACE = (int)((1u<<31) | 0),
++	IPC_EVENT_OUTPUT = (int)((1u<<31) | 1),
++	IPC_EVENT_MODE = (int)((1u<<31) | 2),
++	IPC_EVENT_WINDOW = (int)((1u<<31) | 3),
++	IPC_EVENT_BARCONFIG_UPDATE = (int)((1u<<31) | 4),
++	IPC_EVENT_BINDING = (int)((1u<<31) | 5),
++	IPC_EVENT_SHUTDOWN = (int)((1u<<31) | 6),
++	IPC_EVENT_TICK = (int)((1u<<31) | 7),
++
++	// sway-specific event types
++	IPC_EVENT_BAR_STATE_UPDATE = (int)((1u<<31) | 20),
++	IPC_EVENT_INPUT = (int)((1u<<31) | 21),
++};
++
++enum node_type { N_ROOT, N_OUTPUT, N_WORKSPACE, N_CONTAINER };
++
++static int ipc_socket = -1;
++static struct wl_event_source *ipc_event_source =  NULL;
++static struct sockaddr_un *ipc_sockaddr = NULL;
++static list_t *ipc_client_list = NULL;
++static ssize_t i3_tag = 0;
++static struct wl_listener ipc_display_destroy;
++
++static const char ipc_magic[] = {'i', '3', '-', 'i', 'p', 'c'};
++
++#define IPC_HEADER_SIZE (sizeof(ipc_magic) + 8)
++
++struct ipc_client {
++	struct wl_event_source *event_source;
++	struct wl_event_source *writable_event_source;
++	int fd;
++	enum ipc_command_type subscribed_events;
++	size_t write_buffer_len;
++	size_t write_buffer_size;
++	char *write_buffer;
++	// The following are for storing data between event_loop calls
++	uint32_t pending_length;
++	enum ipc_command_type pending_type;
++};
++
++int ipc_handle_connection(int fd, uint32_t mask, void *data);
++int ipc_client_handle_readable(int client_fd, uint32_t mask, void *data);
++void ipc_client_handle_command(struct ipc_client *client, uint32_t payload_length,
++	enum ipc_command_type payload_type);
++bool ipc_send_reply(struct ipc_client *client, enum ipc_command_type payload_type,
++	const char *payload, uint32_t payload_length);
++/*
++int ipc_client_handle_writable(int client_fd, uint32_t mask, void *data);
++void ipc_client_disconnect(struct ipc_client *client);
++*/
++
+ /* function declarations */
++static void ipc_event_window(Client *window, const char *change);
++static void ipc_event_shutdown(const char *reason);
+ static void applybounds(Client *c, struct wlr_box *bbox);
+ static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
+ 		int32_t exclusive, int32_t margin_top, int32_t margin_right,
+@@ -289,6 +374,7 @@ static void updatemons(struct wl_listener *listener, void *data);
+ static void updatetitle(struct wl_listener *listener, void *data);
+ static void urgent(struct wl_listener *listener, void *data);
+ static void view(const Arg *arg);
++static void viewall(const Arg *arg);
+ static void virtualkeyboard(struct wl_listener *listener, void *data);
+ static Monitor *xytomon(double x, double y);
+ static struct wlr_scene_node *xytonode(double x, double y, struct wlr_surface **psurface,
+@@ -373,6 +459,9 @@ static Atom netatom[NetLast];
+ /* attempt to encapsulate suck into one file */
+ #include "client.h"
+ 
++/* i3 commands compatibility layer */
++#include "commands.c"
++
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+@@ -1075,6 +1164,7 @@ destroynotify(struct wl_listener *listener, void *data)
+ 	} else
+ #endif
+ 		wl_list_remove(&c->commit.link);
++	ipc_event_window(c, "close");
+ 	free(c);
+ }
+ 
+@@ -1153,6 +1243,7 @@ focusclient(Client *c, int lift)
+ 		}
+ 	}
+ 
++	ipc_event_window(c, "focus");
+ 	printstatus();
+ 	wlr_idle_set_enabled(idle, seat, wl_list_empty(&idle_inhibit_mgr->inhibitors));
+ 
+@@ -1412,6 +1503,7 @@ mapnotify(struct wl_listener *listener, void *data)
+ 
+ 	/* Set initial monitor, tags, floating status, and focus */
+ 	applyrules(c);
++	ipc_event_window(c, "new");
+ 	printstatus();
+ 
+ 	if (c->isfullscreen)
+@@ -1662,6 +1754,41 @@ printstatus(void)
+ 	fflush(stdout);
+ }
+ 
++void ipc_client_disconnect(struct ipc_client *client) {
++	int i = 0;
++
++	shutdown(client->fd, SHUT_RDWR);
++
++	wl_event_source_remove(client->event_source);
++	if (client->writable_event_source) {
++		wl_event_source_remove(client->writable_event_source);
++	}
++	while (i < ipc_client_list->length && ipc_client_list->items[i] != client) {
++		i++;
++	}
++	list_del(ipc_client_list, i);
++	free(client->write_buffer);
++	close(client->fd);
++	free(client);
++}
++
++static void handle_display_destroy(struct wl_listener *listener, void *data) {
++	if (ipc_event_source) {
++		wl_event_source_remove(ipc_event_source);
++	}
++	close(ipc_socket);
++	unlink(ipc_sockaddr->sun_path);
++
++	while (ipc_client_list->length) {
++		ipc_client_disconnect(ipc_client_list->items[ipc_client_list->length-1]);
++	}
++	list_free(ipc_client_list);
++
++	free(ipc_sockaddr);
++
++	wl_list_remove(&ipc_display_destroy.link);
++}
++
+ void
+ quit(const Arg *arg)
+ {
+@@ -1747,6 +1874,879 @@ resize(Client *c, int x, int y, int w, int h, int interact)
+ 			c->geom.height - 2 * c->bw);
+ }
+ 
++static bool ipc_has_event_listeners(enum ipc_command_type event) {
++	for (int i = 0; i < ipc_client_list->length; i++) {
++		struct ipc_client *client = ipc_client_list->items[i];
++		if ((client->subscribed_events & event_mask(event)) != 0) {
++			return true;
++		}
++	}
++	return false;
++}
++
++static void ipc_send_event(const char *json_string, enum ipc_command_type event) {
++	struct ipc_client *client;
++	for (int i = 0; i < ipc_client_list->length; i++) {
++		client = ipc_client_list->items[i];
++		if ((client->subscribed_events & event_mask(event)) == 0) {
++			continue;
++		}
++		if (!ipc_send_reply(client, event, json_string,
++				(uint32_t)strlen(json_string))) {
++			fprintf(stderr, "Unable to send reply to IPC client");
++			/* ipc_send_reply destroys client on error, which also
++			 * removes it from the list, so we need to process
++			 * current index again */
++			i--;
++		}
++	}
++}
++
++static void ipc_event_tick(const char *payload) {
++	json_object *json;
++	const char *json_string;
++	if (!ipc_has_event_listeners(IPC_EVENT_TICK)) {
++		return;
++	}
++
++	json = json_object_new_object();
++	json_object_object_add(json, "first", json_object_new_boolean(false));
++	json_object_object_add(json, "payload", json_object_new_string(payload));
++
++	json_string = json_object_to_json_string(json);
++	ipc_send_event(json_string, IPC_EVENT_TICK);
++	json_object_put(json);
++}
++
++struct sockaddr_un *ipc_user_sockaddr(void) {
++	int path_size;
++	struct sockaddr_un *ipc_sockaddr = malloc(sizeof(struct sockaddr_un));
++	// Env var typically set by logind, e.g. "/run/user/<user-id>"
++	const char *dir = getenv("XDG_RUNTIME_DIR");
++
++	if (ipc_sockaddr == NULL) {
++		die("Can't allocate ipc_sockaddr");
++	}
++
++	ipc_sockaddr->sun_family = AF_UNIX;
++	path_size = sizeof(ipc_sockaddr->sun_path);
++
++	if (!dir) {
++		dir = "/tmp";
++	}
++	if (path_size <= snprintf(ipc_sockaddr->sun_path, path_size,
++			"%s/sway-ipc.%u.%i.sock", dir, getuid(), getpid())) {
++		die("Socket path won't fit into ipc_sockaddr->sun_path");
++	}
++
++	return ipc_sockaddr;
++}
++
++int ipc_client_handle_writable(int client_fd, uint32_t mask, void *data) {
++	ssize_t written;
++	struct ipc_client *client = data;
++
++	if (mask & WL_EVENT_ERROR) {
++		fprintf(stderr, "IPC Client socket error, removing client");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	if (mask & WL_EVENT_HANGUP) {
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	if (client->write_buffer_len <= 0) {
++		return 0;
++	}
++
++	written = write(client->fd, client->write_buffer, client->write_buffer_len);
++
++	if (written == -1 && errno == EAGAIN) {
++		return 0;
++	} else if (written == -1) {
++		fprintf(stderr, "Unable to send data from queue to IPC client");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	memmove(client->write_buffer, client->write_buffer + written, client->write_buffer_len - written);
++	client->write_buffer_len -= written;
++
++	if (client->write_buffer_len == 0 && client->writable_event_source) {
++		wl_event_source_remove(client->writable_event_source);
++		client->writable_event_source = NULL;
++	}
++
++	return 0;
++}
++
++static const char *ipc_json_output_transform_description(enum wl_output_transform transform) {
++	switch (transform) {
++	case WL_OUTPUT_TRANSFORM_NORMAL:
++		return "normal";
++	case WL_OUTPUT_TRANSFORM_90:
++		// Sway uses clockwise transforms, while WL_OUTPUT_TRANSFORM_* describes
++		// anti-clockwise transforms.
++		return "270";
++	case WL_OUTPUT_TRANSFORM_180:
++		return "180";
++	case WL_OUTPUT_TRANSFORM_270:
++		// Transform also inverted here.
++		return "90";
++	case WL_OUTPUT_TRANSFORM_FLIPPED:
++		return "flipped";
++	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
++		// Inverted.
++		return "flipped-270";
++	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
++		return "flipped-180";
++	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
++		// Inverted.
++		return "flipped-90";
++	}
++	return NULL;
++}
++
++
++static const char *ipc_json_output_adaptive_sync_status_description(
++		enum wlr_output_adaptive_sync_status status) {
++	switch (status) {
++	case WLR_OUTPUT_ADAPTIVE_SYNC_DISABLED:
++		return "disabled";
++	case WLR_OUTPUT_ADAPTIVE_SYNC_ENABLED:
++		return "enabled";
++	case WLR_OUTPUT_ADAPTIVE_SYNC_UNKNOWN:
++		return "unknown";
++	}
++	return NULL;
++}
++
++static json_object *ipc_json_create_rect(struct wlr_box *box) {
++	json_object *rect = json_object_new_object();
++
++	json_object_object_add(rect, "x", json_object_new_int(box->x));
++	json_object_object_add(rect, "y", json_object_new_int(box->y));
++	json_object_object_add(rect, "width", json_object_new_int(box->width));
++	json_object_object_add(rect, "height", json_object_new_int(box->height));
++
++	return rect;
++}
++
++static json_object *ipc_json_create_empty_rect(void) {
++	struct wlr_box empty = {0, 0, 0, 0};
++
++	return ipc_json_create_rect(&empty);
++}
++
++static json_object *ipc_json_create_node(intptr_t id, const char* type, const char *name,
++		bool focused, struct wlr_box *box) {
++	json_object *object = json_object_new_object();
++
++	json_object_object_add(object, "id", json_object_new_int(abs(id)));
++	json_object_object_add(object, "type", json_object_new_string(type));
++	json_object_object_add(object, "orientation",
++			json_object_new_string("none"));
++	json_object_object_add(object, "percent", NULL);
++	json_object_object_add(object, "urgent", json_object_new_boolean(false));
++	json_object_object_add(object, "marks", json_object_new_array());
++	json_object_object_add(object, "focused", json_object_new_boolean(focused));
++	json_object_object_add(object, "layout",
++			json_object_new_string("splith"));
++
++	// set default values to be compatible with i3
++	json_object_object_add(object, "border",
++			json_object_new_string("none"));
++	json_object_object_add(object, "current_border_width",
++			json_object_new_int(0));
++	json_object_object_add(object, "rect", ipc_json_create_rect(box));
++	json_object_object_add(object, "deco_rect", ipc_json_create_empty_rect());
++	json_object_object_add(object, "window_rect", ipc_json_create_empty_rect());
++	json_object_object_add(object, "geometry", ipc_json_create_empty_rect());
++	json_object_object_add(object, "name",
++			name ? json_object_new_string(name) : NULL);
++	json_object_object_add(object, "window", NULL);
++	json_object_object_add(object, "nodes", json_object_new_array());
++	json_object_object_add(object, "floating_nodes", json_object_new_array());
++	json_object_object_add(object, "focus", json_object_new_array());
++	json_object_object_add(object, "fullscreen_mode", json_object_new_int(0));
++	json_object_object_add(object, "sticky", json_object_new_boolean(false));
++
++	return object;
++}
++
++json_object* ipc_json_describe_client(Client *c) {
++	json_object *object;
++	bool visible;
++	Monitor *tempm;
++	struct wlr_box deco_box = {c->geom.x-borderpx, c->geom.y-borderpx, c->geom.width + borderpx, c->geom.height + borderpx};
++	object = ipc_json_create_node((intptr_t)c, "con", client_get_title(c), seat->keyboard_state.focused_surface == client_surface(c), &c->geom);
++	if (c->isfloating) {
++		json_object_object_add(object, "type",
++				json_object_new_string("floating_con"));
++	}
++
++	json_object_object_add(object, "layout",
++			json_object_new_string("none"));
++
++	json_object_object_add(object, "orientation",
++			json_object_new_string("none"));
++
++	json_object_object_add(object, "urgent", json_object_new_boolean(c->isurgent));
++
++	json_object_object_add(object, "fullscreen_mode",
++			json_object_new_int(c->isfullscreen));
++
++	if (deco_box.width != 0 && deco_box.height != 0) {
++		double percent = ((double)c->geom.width / deco_box.width)
++				* ((double)c->geom.height / deco_box.height);
++		json_object_object_add(object, "percent", json_object_new_double(percent));
++	}
++
++	json_object_object_add(object, "border",
++			json_object_new_string("pixel"));
++	json_object_object_add(object, "current_border_width",
++			json_object_new_int(borderpx));
++	json_object_object_add(object, "floating_nodes", json_object_new_array());
++
++	json_object_object_add(object, "deco_rect", ipc_json_create_rect(&deco_box));
++
++	/*
++	json_object *marks = json_object_new_array();
++	list_t *con_marks = c->marks;
++	for (int i = 0; i < con_marks->length; ++i) {
++		json_object_array_add(marks, json_object_new_string(con_marks->items[i]));
++	}
++
++	json_object_object_add(object, "marks", marks);
++	*/
++
++	// json_object_object_add(object, "pid", json_object_new_int(client_get_pid(c)));
++
++	const char *app_id = client_get_appid(c);
++	json_object_object_add(object, "app_id",
++			app_id ? json_object_new_string(app_id) : NULL);
++
++	wl_list_for_each(tempm, &mons, link) {
++		if (VISIBLEON(c, tempm)) {
++			visible = true;
++		}
++	}
++	json_object_object_add(object, "visible", json_object_new_boolean(visible));
++
++	json_object_object_add(object, "window_rect", ipc_json_create_rect(&c->geom));
++
++	json_object_object_add(object, "geometry", ipc_json_create_rect(&c->geom));
++
++	json_object_object_add(object, "max_render_time", json_object_new_int(0));
++
++	/*
++	json_object_object_add(object, "shell", json_object_new_string(view_get_shell(c->view)));
++
++	json_object_object_add(object, "inhibit_idle",
++		json_object_new_boolean(view_inhibit_idle(c->view)));
++
++	json_object *idle_inhibitors = json_object_new_object();
++
++	struct sway_idle_inhibitor_v1 *user_inhibitor =
++		sway_idle_inhibit_v1_user_inhibitor_for_view(c->view);
++
++	if (user_inhibitor) {
++		json_object_object_add(idle_inhibitors, "user",
++			json_object_new_string(
++				ipc_json_user_idle_inhibitor_description(user_inhibitor->mode)));
++	} else {
++		json_object_object_add(idle_inhibitors, "user",
++			json_object_new_string("none"));
++	}
++
++	struct sway_idle_inhibitor_v1 *application_inhibitor =
++		sway_idle_inhibit_v1_application_inhibitor_for_view(c->view);
++
++	if (application_inhibitor) {
++		json_object_object_add(idle_inhibitors, "application",
++			json_object_new_string("enabled"));
++	} else {
++		json_object_object_add(idle_inhibitors, "application",
++			json_object_new_string("none"));
++	}
++
++	json_object_object_add(object, "idle_inhibitors", idle_inhibitors);
++
++#if XWAYLAND
++	if (c->view->type == SWAY_VIEW_XWAYLAND) {
++		json_object_object_add(object, "window",
++				json_object_new_int(view_get_x11_window_id(c->view)));
++
++		json_object *window_props = json_object_new_object();
++
++		const char *class = view_get_class(c->view);
++		if (class) {
++			json_object_object_add(window_props, "class", json_object_new_string(class));
++		}
++		const char *instance = view_get_instance(c->view);
++		if (instance) {
++			json_object_object_add(window_props, "instance", json_object_new_string(instance));
++		}
++		if (c->title) {
++			json_object_object_add(window_props, "title", json_object_new_string(c->title));
++		}
++
++		// the transient_for key is always present in i3's output
++		uint32_t parent_id = view_get_x11_parent_id(c->view);
++		json_object_object_add(window_props, "transient_for",
++				parent_id ? json_object_new_int(parent_id) : NULL);
++
++		const char *role = view_get_window_role(c->view);
++		if (role) {
++			json_object_object_add(window_props, "window_role", json_object_new_string(role));
++		}
++
++		uint32_t window_type = view_get_window_type(c->view);
++		if (window_type) {
++			json_object_object_add(window_props, "window_type",
++				json_object_new_string(
++					ipc_json_xwindow_type_description(c->view)));
++		}
++
++		json_object_object_add(object, "window_properties", window_props);
++	}
++#endif
++	*/
++	return object;
++}
++
++void ipc_event_shutdown(const char *reason) {
++	json_object *json;
++	const char *json_string;
++	if (!ipc_has_event_listeners(IPC_EVENT_SHUTDOWN)) {
++		return;
++	}
++
++	json = json_object_new_object();
++	json_object_object_add(json, "change", json_object_new_string(reason));
++
++	json_string = json_object_to_json_string(json);
++	ipc_send_event(json_string, IPC_EVENT_SHUTDOWN);
++	json_object_put(json);
++}
++
++void ipc_event_window(Client *window, const char *change) {
++	json_object *obj;
++	const char *json_string; 
++	if (!ipc_has_event_listeners(IPC_EVENT_WINDOW) || window == NULL) {
++		return;
++	}
++	obj = json_object_new_object();
++	json_object_object_add(obj, "change", json_object_new_string(change));
++	json_object_object_add(obj, "container", ipc_json_describe_client(window));
++
++	json_string = json_object_to_json_string(obj);
++	ipc_send_event(json_string, IPC_EVENT_WINDOW);
++	json_object_put(obj);
++}
++
++json_object* ipc_get_workspaces_callback(ssize_t i, Monitor *m) {
++	Monitor *tempm;
++	Client *c;
++	bool visible = false;
++	json_object *children = json_object_new_array();
++	json_object *workspace_json = ipc_json_create_node((intptr_t)m, "workspace", tags[i], (1 << i) & selmon->tagset[selmon->seltags], &m->w);
++
++	wl_list_for_each(tempm, &mons, link) {
++		if ((1 << i) & tempm->tagset[tempm->seltags]) {
++			visible = true;
++		}
++	}
++
++
++	json_object_object_add(workspace_json, "num", json_object_new_int(i + 1));
++	json_object_object_add(workspace_json, "fullscreen_mode", json_object_new_int(1));
++	json_object_object_add(workspace_json, "representation", json_object_new_string("D[]"));
++	json_object_object_add(workspace_json, "visible", json_object_new_boolean(visible));
++	json_object_object_add(workspace_json, "output", json_object_new_string(selmon->wlr_output->name));
++	wl_list_for_each(c, &clients, link) {
++		if (c->tags == (1 << i)) {
++			json_object_array_add(children, ipc_json_describe_client(c));
++		}
++	}
++	json_object_object_add(workspace_json, "nodes", children);
++	return workspace_json;
++}
++
++json_object* ipc_json_describe_output(Monitor *m) {
++	json_object *object = ipc_json_create_node((intptr_t)m, "output", m->wlr_output->name, false, &m->w);
++	struct wlr_output *wlr_output = m->wlr_output;
++	struct wlr_output_mode *mode;
++	ssize_t i;
++	const char *adaptive_sync_status;
++	json_object *modes_array = json_object_new_array();
++	json_object *children = json_object_new_array();
++	json_object *current_mode_object = json_object_new_object();
++
++	json_object_object_add(object, "primary", json_object_new_boolean(false));
++	json_object_object_add(object, "make",
++			json_object_new_string(wlr_output->make));
++	json_object_object_add(object, "model",
++			json_object_new_string(wlr_output->model));
++	json_object_object_add(object, "serial",
++			json_object_new_string(wlr_output->serial));
++
++	wl_list_for_each(mode, &wlr_output->modes, link) {
++		json_object *mode_object = json_object_new_object();
++		json_object_object_add(mode_object, "width",
++			json_object_new_int(mode->width));
++		json_object_object_add(mode_object, "height",
++			json_object_new_int(mode->height));
++		json_object_object_add(mode_object, "refresh",
++			json_object_new_int(mode->refresh));
++		json_object_array_add(modes_array, mode_object);
++	}
++	json_object_object_add(object, "modes", modes_array);
++	json_object_object_add(object, "active", json_object_new_boolean(true));
++	json_object_object_add(object, "dpms",
++			json_object_new_boolean(wlr_output->enabled));
++	json_object_object_add(object, "layout", json_object_new_string("output"));
++	json_object_object_add(object, "orientation",
++			json_object_new_string("none"));
++	json_object_object_add(object, "scale",
++			json_object_new_double(wlr_output->scale));
++	/*
++	json_object_object_add(object, "scale_filter",
++		json_object_new_string(
++			sway_output_scale_filter_to_string(output->scale_filter)));
++	*/
++	json_object_object_add(object, "transform",
++		json_object_new_string(
++			ipc_json_output_transform_description(wlr_output->transform)));
++	adaptive_sync_status =
++		ipc_json_output_adaptive_sync_status_description(
++			wlr_output->adaptive_sync_status);
++	json_object_object_add(object, "adaptive_sync_status",
++		json_object_new_string(adaptive_sync_status));
++
++
++	for (i = 0; i < LENGTH(tags); i++) {
++		if ((1 << i) & m->tagset[m->seltags]) {
++	json_object_object_add(object, "current_workspace",
++			json_object_new_string(tags[i]));
++			break;
++		}
++	}
++
++	json_object_object_add(current_mode_object, "width",
++		json_object_new_int(wlr_output->width));
++	json_object_object_add(current_mode_object, "height",
++		json_object_new_int(wlr_output->height));
++	json_object_object_add(current_mode_object, "refresh",
++		json_object_new_int(wlr_output->refresh));
++	json_object_object_add(object, "current_mode", current_mode_object);
++
++	if (m->m.width != 0 && m->m.height != 0) {
++		double percent = ((double)m->w.width / m->m.width)
++				* ((double)m->w.height / m->m.height);
++		json_object_object_add(object, "percent", json_object_new_double(percent));
++	}
++
++	for (i = 0; i < LENGTH(tags); i++) {
++		json_object_array_add(children, ipc_get_workspaces_callback(i, m));
++	}
++	json_object_object_add(object, "nodes", children);
++
++	return object;
++}
++
++json_object* ipc_json_node_tree(void) {
++	Monitor *tempm;
++	json_object *full_obj;
++	json_object* children = json_object_new_array();
++	struct wlr_box full_box = {0, 0, 0, 0};
++	wl_list_for_each(tempm, &mons, link) {
++		if (tempm->m.x < full_box.x) {
++			full_box.x = tempm->m.x;
++		}
++		if (tempm->m.y < full_box.y) {
++			full_box.y = tempm->m.y;
++		}
++		if (tempm->m.x + tempm->m.width > full_box.width) {
++			full_box.width = tempm->m.x + tempm->m.width;
++		}
++		if (tempm->m.y + tempm->m.height > full_box.height) {
++			full_box.height = tempm->m.y + tempm->m.height;
++		}
++	}
++	full_box.width = full_box.width - full_box.x;
++	full_box.height = full_box.height - full_box.y;
++	full_obj = ipc_json_create_node(1, "root", "root", false, &full_box);
++	wl_list_for_each(tempm, &mons, link) {
++		json_object_array_add(children, ipc_json_describe_output(tempm));	
++	}
++	json_object_object_add(full_obj, "nodes", children);
++	return full_obj;
++}
++
++void ipc_client_handle_command(struct ipc_client *client, uint32_t payload_length,
++		enum ipc_command_type payload_type) {
++	char *buf;
++	const char msg[] = "{\"success\": true}";
++	bool is_tick;
++	list_t *res_list;
++	ssize_t i;
++	const char *json_string;
++	if (client == NULL) {
++		return;
++	}
++
++	buf = malloc(payload_length + 1);
++	if (!buf) {
++		fprintf(stderr, "Unable to allocate IPC payload");
++		ipc_client_disconnect(client);
++		return;
++	}
++	if (payload_length > 0) {
++		// Payload should be fully available
++		ssize_t received = recv(client->fd, buf, payload_length, 0);
++		if (received == -1)
++		{
++			fprintf(stderr, "Unable to receive payload from IPC client");
++			ipc_client_disconnect(client);
++			free(buf);
++			return;
++		}
++	}
++	buf[payload_length] = '\0';
++	switch (payload_type) {
++	case IPC_COMMAND:
++	{
++		char *line = strtok(buf, "\n");
++		while (line) {
++			size_t line_length = strlen(line);
++			if (line + line_length >= buf + payload_length) {
++				break;
++			}
++			line[line_length] = ';';
++			line = strtok(NULL, "\n");
++		}
++
++		res_list = execute_command(buf, NULL);
++		buf = cmd_results_to_json(res_list);
++		i = strlen(buf);
++		ipc_send_reply(client, payload_type, buf, (uint32_t)i);
++		while (res_list->length) {
++			struct cmd_results *results = res_list->items[0];
++			free_cmd_results(results);
++			list_del(res_list, 0);
++		}
++		list_free(res_list);
++		goto exit_cleanup;
++	}
++
++	case IPC_SEND_TICK:
++	{
++		ipc_event_tick(buf);
++		ipc_send_reply(client, payload_type, "{\"success\": true}", 17);
++		goto exit_cleanup;
++	}
++
++	case IPC_GET_WORKSPACES:
++	{
++		json_object *workspaces = json_object_new_array();
++		for (i = 0; i < LENGTH(tags); i++) {
++			json_object_array_add(workspaces, ipc_get_workspaces_callback(i, selmon));	
++		}
++		json_string = json_object_to_json_string(workspaces);
++		ipc_send_reply(client, payload_type, json_string,
++			(uint32_t)strlen(json_string));
++		json_object_put(workspaces); // free
++		goto exit_cleanup;
++	}
++
++	case IPC_SUBSCRIBE:
++	{
++		// TODO: Check if they're permitted to use these events
++		struct json_object *request = json_tokener_parse(buf);
++		if (request == NULL || !json_object_is_type(request, json_type_array)) {
++			const char msg[] = "{\"success\": false}";
++			ipc_send_reply(client, payload_type, msg, strlen(msg));
++			fprintf(stderr, "Failed to parse subscribe request");
++			goto exit_cleanup;
++		}
++
++		is_tick = false;
++		// parse requested event types
++		for (size_t i = 0; i < json_object_array_length(request); i++) {
++			const char *event_type = json_object_get_string(json_object_array_get_idx(request, i));
++			if (strcmp(event_type, "workspace") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_WORKSPACE);
++			} else if (strcmp(event_type, "barconfig_update") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_BARCONFIG_UPDATE);
++			} else if (strcmp(event_type, "bar_state_update") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_BAR_STATE_UPDATE);
++			} else if (strcmp(event_type, "mode") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_MODE);
++			} else if (strcmp(event_type, "shutdown") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_SHUTDOWN);
++			} else if (strcmp(event_type, "window") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_WINDOW);
++			} else if (strcmp(event_type, "binding") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_BINDING);
++			} else if (strcmp(event_type, "tick") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_TICK);
++				is_tick = true;
++			} else if (strcmp(event_type, "input") == 0) {
++				client->subscribed_events |= event_mask(IPC_EVENT_INPUT);
++			} else {
++				const char msg[] = "{\"success\": false}";
++				ipc_send_reply(client, payload_type, msg, strlen(msg));
++				json_object_put(request);
++				fprintf(stderr, "Unsupported event type in subscribe request");
++				goto exit_cleanup;
++			}
++		}
++
++		json_object_put(request);
++		ipc_send_reply(client, payload_type, msg, strlen(msg));
++		if (is_tick) {
++			const char tickmsg[] = "{\"first\": true, \"payload\": \"\"}";
++			ipc_send_reply(client, IPC_EVENT_TICK, tickmsg,
++				strlen(tickmsg));
++		}
++		goto exit_cleanup;
++	}
++
++	case IPC_GET_TREE:
++	{
++		json_object *tree = ipc_json_node_tree();
++		const char *json_string = json_object_to_json_string(tree);
++		ipc_send_reply(client, payload_type, json_string,
++			(uint32_t)strlen(json_string));
++		json_object_put(tree);
++		goto exit_cleanup;
++	}
++
++
++	default:
++		fprintf(stderr, "Unknown IPC command type %x", payload_type);
++		goto exit_cleanup;
++	}
++
++exit_cleanup:
++	free(buf);
++	return;
++}
++
++void ipc_init(void) {
++	ipc_socket = socket(AF_UNIX, SOCK_STREAM, 0);
++	if (ipc_socket == -1) {
++		die("Unable to create IPC socket");
++	}
++	if (fcntl(ipc_socket, F_SETFD, FD_CLOEXEC) == -1) {
++		die("Unable to set CLOEXEC on IPC socket");
++	}
++	if (fcntl(ipc_socket, F_SETFL, O_NONBLOCK) == -1) {
++		die("Unable to set NONBLOCK on IPC socket");
++	}
++
++	ipc_sockaddr = ipc_user_sockaddr();
++
++	// We want to use socket name set by user, not existing socket from another sway instance.
++	if (getenv("SWAYSOCK") != NULL && access(getenv("SWAYSOCK"), F_OK) == -1) {
++		strncpy(ipc_sockaddr->sun_path, getenv("SWAYSOCK"), sizeof(ipc_sockaddr->sun_path) - 1);
++		ipc_sockaddr->sun_path[sizeof(ipc_sockaddr->sun_path) - 1] = 0;
++	}
++
++	unlink(ipc_sockaddr->sun_path);
++	if (bind(ipc_socket, (struct sockaddr *)ipc_sockaddr, sizeof(*ipc_sockaddr)) == -1) {
++		die("Unable to bind IPC socket");
++	}
++
++	if (listen(ipc_socket, 3) == -1) {
++		die("Unable to listen on IPC socket");
++	}
++
++	// Set i3 IPC socket path so that i3-msg works out of the box
++	setenv("I3SOCK", ipc_sockaddr->sun_path, 1);
++	setenv("SWAYSOCK", ipc_sockaddr->sun_path, 1);
++
++	ipc_client_list = create_list();
++
++	ipc_display_destroy.notify = handle_display_destroy;
++	wl_display_add_destroy_listener(dpy, &ipc_display_destroy);
++
++	ipc_event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy), ipc_socket,
++			WL_EVENT_READABLE, ipc_handle_connection, NULL);
++}
++
++int ipc_handle_connection(int fd, uint32_t mask, void *data) {
++	int flags;
++	int client_fd;
++	struct ipc_client *client;
++
++	(void) fd;
++	if (!(mask == WL_EVENT_READABLE)) {
++		return 0;
++	}
++
++	client_fd = accept(ipc_socket, NULL, NULL);
++	if (client_fd == -1) {
++		fprintf(stderr, "Unable to accept IPC client connection");
++		return 0;
++	}
++
++	if ((flags = fcntl(client_fd, F_GETFD)) == -1
++			|| fcntl(client_fd, F_SETFD, flags|FD_CLOEXEC) == -1) {
++		fprintf(stderr, "Unable to set CLOEXEC on IPC client socket");
++		close(client_fd);
++		return 0;
++	}
++	if ((flags = fcntl(client_fd, F_GETFL)) == -1
++			|| fcntl(client_fd, F_SETFL, flags|O_NONBLOCK) == -1) {
++		fprintf(stderr, "Unable to set NONBLOCK on IPC client socket");
++		close(client_fd);
++		return 0;
++	}
++
++	client = malloc(sizeof(struct ipc_client));
++	if (!client) {
++		fprintf(stderr, "Unable to allocate ipc client");
++		close(client_fd);
++		return 0;
++	}
++	client->pending_length = 0;
++	client->fd = client_fd;
++	client->subscribed_events = 0;
++	client->event_source = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
++			client_fd, WL_EVENT_READABLE, ipc_client_handle_readable, client);
++	client->writable_event_source = NULL;
++
++	client->write_buffer_size = 128;
++	client->write_buffer_len = 0;
++	client->write_buffer = malloc(client->write_buffer_size);
++	if (!client->write_buffer) {
++		fprintf(stderr, "Unable to allocate ipc client write buffer");
++		close(client_fd);
++		return 0;
++	}
++
++	list_add(ipc_client_list, client);
++	return 0;
++}
++
++int ipc_client_handle_readable(int client_fd, uint32_t mask, void *data) {
++	int read_available;
++	uint8_t buf[IPC_HEADER_SIZE];
++	ssize_t received;
++	struct ipc_client *client = data;
++
++	if (mask & WL_EVENT_ERROR) {
++		fprintf(stderr, "IPC Client socket error, removing client");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	if (mask & WL_EVENT_HANGUP) {
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	if (ioctl(client_fd, FIONREAD, &read_available) == -1) {
++		fprintf(stderr, "Unable to read IPC socket buffer size");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	// Wait for the rest of the command payload in case the header has already been read
++	if (client->pending_length > 0) {
++		if ((uint32_t)read_available >= client->pending_length) {
++			// Reset pending values.
++			uint32_t pending_length = client->pending_length;
++			enum ipc_command_type pending_type = client->pending_type;
++			client->pending_length = 0;
++			ipc_client_handle_command(client, pending_length, pending_type);
++		}
++		return 0;
++	}
++
++	if (read_available < (int) IPC_HEADER_SIZE) {
++		return 0;
++	}
++
++	// Should be fully available, because read_available >= IPC_HEADER_SIZE
++	received = recv(client_fd, buf, IPC_HEADER_SIZE, 0);
++	if (received == -1) {
++		fprintf(stderr, "Unable to receive header from IPC client");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	if (memcmp(buf, ipc_magic, sizeof(ipc_magic)) != 0) {
++		fprintf(stderr, "IPC header check failed");
++		ipc_client_disconnect(client);
++		return 0;
++	}
++
++	memcpy(&client->pending_length, buf + sizeof(ipc_magic), sizeof(uint32_t));
++	memcpy(&client->pending_type, buf + sizeof(ipc_magic) + sizeof(uint32_t), sizeof(uint32_t));
++
++	if (read_available - received >= (long)client->pending_length) {
++		// Reset pending values.
++		uint32_t pending_length = client->pending_length;
++		enum ipc_command_type pending_type = client->pending_type;
++		client->pending_length = 0;
++		ipc_client_handle_command(client, pending_length, pending_type);
++	}
++
++	return 0;
++}
++
++bool ipc_send_reply(struct ipc_client *client, enum ipc_command_type payload_type,
++		const char *payload, uint32_t payload_length) {
++	char data[IPC_HEADER_SIZE];
++	char *new_buffer;
++	if (payload == NULL) {
++		return false;
++	}
++
++
++	memcpy(data, ipc_magic, sizeof(ipc_magic));
++	memcpy(data + sizeof(ipc_magic), &payload_length, sizeof(payload_length));
++	memcpy(data + sizeof(ipc_magic) + sizeof(payload_length), &payload_type, sizeof(payload_type));
++
++	while (client->write_buffer_len + IPC_HEADER_SIZE + payload_length >=
++				 client->write_buffer_size) {
++		client->write_buffer_size *= 2;
++	}
++
++	if (client->write_buffer_size > 4e6) { // 4 MB
++		fprintf(stderr, "Client write buffer too big (%zu), disconnecting client",
++				client->write_buffer_size);
++		ipc_client_disconnect(client);
++		return false;
++	}
++
++	new_buffer = realloc(client->write_buffer, client->write_buffer_size);
++	if (!new_buffer) {
++		fprintf(stderr, "Unable to reallocate ipc client write buffer");
++		ipc_client_disconnect(client);
++		return false;
++	}
++	client->write_buffer = new_buffer;
++
++	memcpy(client->write_buffer + client->write_buffer_len, data, IPC_HEADER_SIZE);
++	client->write_buffer_len += IPC_HEADER_SIZE;
++	memcpy(client->write_buffer + client->write_buffer_len, payload, payload_length);
++	client->write_buffer_len += payload_length;
++
++	if (!client->writable_event_source) {
++		client->writable_event_source = wl_event_loop_add_fd(
++				wl_display_get_event_loop(dpy), client->fd, WL_EVENT_WRITABLE,
++				ipc_client_handle_writable, client);
++	}
++
++	return true;
++}
++
+ void
+ run(char *startup_cmd)
+ {
+@@ -1756,6 +2756,7 @@ run(char *startup_cmd)
+ 	const char *socket = wl_display_add_socket_auto(dpy);
+ 	if (!socket)
+ 		die("startup: display_add_socket_auto");
++	ipc_init();
+ 	setenv("WAYLAND_DISPLAY", socket, 1);
+ 
+ 	/* Now that the socket exists, run the startup command */
+@@ -1842,6 +2843,7 @@ setfloating(Client *c, int floating)
+ 	c->isfloating = floating;
+ 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
+ 	arrange(c->mon);
++	ipc_event_window(c, "floating");
+ 	printstatus();
+ }
+ 
+@@ -1861,6 +2863,7 @@ setfullscreen(Client *c, int fullscreen)
+ 		resize(c, c->prev.x, c->prev.y, c->prev.width, c->prev.height, 0);
+ 	}
+ 	arrange(c->mon);
++	ipc_event_window(c, "fullscreen_mode");
+ 	printstatus();
+ }
+ 
+@@ -2237,13 +3240,28 @@ toggletag(const Arg *arg)
+ void
+ toggleview(const Arg *arg)
+ {
+-	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+-
++	json_object *obj;
++	const char *json_string;
++	unsigned int tag, newtagset;
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		obj = json_object_new_object();
++		json_object_object_add(obj, "change", json_object_new_string("focus"));
++		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, selmon));
++	}
++	i3_tag = arg->ui;
++	tag = 1 << arg->ui;
++	newtagset = selmon->tagset[selmon->seltags] ^ (tag & TAGMASK);
+ 	if (newtagset) {
+ 		selmon->tagset[selmon->seltags] = newtagset;
+ 		focusclient(focustop(selmon), 1);
+ 		arrange(selmon);
+ 	}
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
++		json_string = json_object_to_json_string(obj);
++		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
++		json_object_put(obj);
++	}
+ 	printstatus();
+ }
+ 
+@@ -2334,6 +3352,7 @@ updatetitle(struct wl_listener *listener, void *data)
+ 	Client *c = wl_container_of(listener, c, set_title);
+ 	if (c == focustop(c->mon))
+ 		printstatus();
++	ipc_event_window(c, "title");
+ }
+ 
+ void
+@@ -2343,23 +3362,195 @@ urgent(struct wl_listener *listener, void *data)
+ 	Client *c = client_from_wlr_surface(event->surface);
+ 	if (c != selclient()) {
+ 		c->isurgent = 1;
++		ipc_event_window(c, "urgent");
+ 		printstatus();
+ 	}
+ }
+ 
+ void
+-view(const Arg *arg)
++switchtag(unsigned int tag, Monitor *m)
+ {
+-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
++	json_object *obj;
++	const char *json_string;
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		obj = json_object_new_object();
++		json_object_object_add(obj, "change", json_object_new_string("focus"));
++		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, m));
++	}
++	i3_tag = tag;
++	tag = 1 << tag;
++	if ((tag & TAGMASK) == m->tagset[m->seltags])
++		return;
++	m->seltags ^= 1; /* toggle sel tagset */
++	if (tag & TAGMASK)
++		m->tagset[m->seltags] = tag & TAGMASK;
++	focusclient(focustop(m), 1);
++	arrange(m);
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
++		json_string = json_object_to_json_string(obj);
++		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
++		json_object_put(obj);
++	}
++	printstatus();
++}
++
++void
++viewall(const Arg *arg)
++{
++	json_object *obj;
++	const char *json_string;
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		obj = json_object_new_object();
++		json_object_object_add(obj, "change", json_object_new_string("focus"));
++		json_object_object_add(obj, "old", ipc_get_workspaces_callback(i3_tag, selmon));
++	}
++	i3_tag = 0;
++	if ((~0 & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+-	if (arg->ui & TAGMASK)
+-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
++	if (~0 & TAGMASK)
++		selmon->tagset[selmon->seltags] = ~0 & TAGMASK;
+ 	focusclient(focustop(selmon), 1);
+ 	arrange(selmon);
++	if (ipc_has_event_listeners(IPC_EVENT_WORKSPACE)) {
++		json_object_object_add(obj, "current", ipc_get_workspaces_callback(i3_tag, selmon));
++		json_string = json_object_to_json_string(obj);
++		ipc_send_event(json_string, IPC_EVENT_WORKSPACE);
++		json_object_put(obj);
++	}
+ 	printstatus();
+ }
+ 
++struct cmd_results *
++cmd_workspace(int argc, char **argv)
++{
++	struct cmd_results *error = NULL;
++	int output_location = -1;
++	unsigned int i;
++	ssize_t tag;
++	Monitor *m;
++	ssize_t j;
++	char *ws_name;
++	if ((error = checkarg(argc, "workspace", EXPECTED_AT_LEAST, 1))) {
++		return error;
++	}	
++	for (i = 0; i < argc; ++i) {
++		if (strcasecmp(argv[i], "output") == 0) {
++			output_location = i;
++			break;
++		}
++	}
++
++	if (output_location == 0) {
++		return cmd_results_new(CMD_INVALID,
++			"Expected 'workspace <name> output <output>'");
++	} else if (output_location > 0) {
++		if ((error = checkarg(argc, "workspace", EXPECTED_AT_LEAST,
++						output_location + 2))) {
++			return error;
++		}
++		ws_name = join_args(argv, output_location);
++		for (j = 0; j < LENGTH(tags); j++) {
++			if (strcmp(tags[j], ws_name) == 0) {
++				tag = j;
++				break;
++			}
++		}
++		i = output_location + 1;
++		wl_list_for_each(m, &mons, link) {
++			if (i > argc) {
++				break;
++			}
++			if (strcmp(argv[i], m->wlr_output->name) == 0) {
++				switchtag(tag, m);
++			}
++			i++;
++		}
++		free(ws_name);
++	} else {
++		m = selmon;
++		/*
++		if (root->fullscreen_global) {
++			return cmd_results_new(CMD_FAILURE, "workspace",
++				"Can't switch workspaces while fullscreen global");
++		}
++		*/
++
++		/*
++		while (strcasecmp(argv[0], "--no-auto-back-and-forth") == 0) {
++			auto_back_and_forth = false;
++			if ((error = checkarg(--argc, "workspace", EXPECTED_AT_LEAST, 1))) {
++				return error;
++			}
++			++argv;
++		}
++		*/
++
++		if (strcasecmp(argv[0], "number") == 0) {
++			if (argc < 2) {
++				return cmd_results_new(CMD_INVALID,
++						"Expected workspace number");
++			}
++			if (!isdigit(argv[1][0])) {
++				return cmd_results_new(CMD_INVALID,
++						"Invalid workspace number '%s'", argv[1]);
++			}
++			switchtag(atoi(argv[1]), m);
++			/*
++			if (ws && auto_back_and_forth) {
++				ws = workspace_auto_back_and_forth(ws);
++			}
++			*/
++		} /* else if (strcasecmp(argv[0], "next") == 0 ||
++				strcasecmp(argv[0], "prev") == 0 ||
++				strcasecmp(argv[0], "next_on_output") == 0 ||
++				strcasecmp(argv[0], "prev_on_output") == 0 ||
++				strcasecmp(argv[0], "current") == 0) {
++			for (i = 0; i < LENGTH(tags); i++) {
++				if (strcmp(tags[i], argv[0])) {
++					view((Arg*)&i);
++					break;
++				}
++			}
++		
++		}  else if (strcasecmp(argv[0], "back_and_forth") == 0) {
++			if (!seat->prev_workspace_name) {
++				return cmd_results_new(CMD_INVALID,
++						"There is no previous workspace");
++			}
++			for (i = 0; i < LENGTH(tags); i++) {
++				if (strcmp(tags[i], argv[0])) {
++					m->seltags = 1 << (unsigned int)i;
++					break;
++				}
++			}
++		} */ else {
++			char *name = join_args(argv, argc);
++			for (i = 0; i < LENGTH(tags); i++) {
++				if (strcmp(tags[i], name) == 0) {
++					switchtag(i, m);
++					break;
++				}
++			}
++			free(name);
++			/*
++			if (ws && auto_back_and_forth) {
++				ws = workspace_auto_back_and_forth(ws);
++			}
++			*/
++		}
++	}
++	return cmd_results_new(CMD_SUCCESS, NULL);
++}
++
++
++inline void
++view(const Arg *arg)
++{
++	switchtag(arg->ui, selmon);
++}
++
+ void
+ virtualkeyboard(struct wl_listener *listener, void *data)
+ {
+@@ -2436,6 +3627,7 @@ zoom(const Arg *arg)
+ 	wl_list_remove(&sel->link);
+ 	wl_list_insert(&clients, &sel->link);
+ 
++	ipc_event_window(sel, "move");
+ 	focusclient(sel, 1);
+ 	arrange(selmon);
+ }
+diff --git a/hmm.log b/hmm.log
+new file mode 100644
+index 0000000..cbfef14
+--- /dev/null
++++ b/hmm.log
+@@ -0,0 +1,24 @@
++M 20:24:14.427933    m-lua-scripting ../modules/module-lua-scripting/api/config.c:80:load_components: Failed to open module /usr/local/lib/wireplumber-0.4/libwireplumber-module-logind: /usr/local/lib/wireplumber-0.4/libwireplumber-module-logind.so: cannot open shared object file: No such file or directory
++M 20:24:14.436613          wp-device ../lib/wp/device.c:619:wp_spa_device_new_from_spa_factory: SPA handle 'api.libcamera.enum.manager' could not be loaded; is it installed?
++M 20:24:14.436662   script/libcamera libcamera.lua:168:chunk: PipeWire's libcamera SPA missing or broken. libcamera not supported.
++M 20:24:14.487389          wp-device ../lib/wp/device.c:619:wp_spa_device_new_from_spa_factory: SPA handle 'api.alsa.acp.device' could not be loaded; is it installed?
++W 20:24:14.487436        script/alsa alsa.lua:190:createDevice: Failed to create 'api.alsa.acp.device' device
++W 20:24:14.569268           spa.alsa ../pipewire/spa/plugins/alsa/acp/alsa-ucm.c:976:probe_volumes: Path Mic ACP LED is not a volume or mute control
++dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.a11y.Bus' requested by ':1.6' (uid=1000 pid=6637 comm="waybar")
++dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.a11y.Bus'
++dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.portal.Desktop' requested by ':1.5' (uid=1000 pid=6637 comm="waybar")
++dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.portal.Documents' requested by ':1.8' (uid=1000 pid=6661 comm="/usr/lib/xdg-desktop-portal")
++dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.impl.portal.PermissionStore' requested by ':1.9' (uid=1000 pid=6666 comm="/usr/lib/xdg-document-portal")
++dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.impl.portal.PermissionStore'
++dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.portal.Documents'
++
++** (/usr/lib/xdg-desktop-portal:6661): WARNING **: 20:24:14.719: No skeleton to export
++dbus-daemon[6607]: [session uid=1000 pid=6607] Activating service name='org.freedesktop.impl.portal.desktop.wlr' requested by ':1.8' (uid=1000 pid=6661 comm="/usr/lib/xdg-desktop-portal")
++2022/06/08 20:24:14 [ERROR] - config: no config file found
++dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.impl.portal.desktop.wlr'
++dbus-daemon[6607]: [session uid=1000 pid=6607] Successfully activated service 'org.freedesktop.portal.Desktop'
++dbus-daemon[6658]: Activating service name='org.a11y.atspi.Registry' requested by ':1.0' (uid=1000 pid=6637 comm="waybar")
++dbus-daemon[6658]: Successfully activated service 'org.a11y.atspi.Registry'
++
++** (waybar:6637): WARNING **: 20:24:14.761: gtk-layer-shell v0.7.0 may not work on GTK v3.24.34. If you experience crashes, check https://github.com/wmww/gtk-layer-shell/blob/master/compatibility.md
++M 20:24:30.692356        wireplumber ../src/main.c:360:on_disconnected: disconnected from pipewire
+diff --git a/list.c b/list.c
+new file mode 100644
+index 0000000..bb9ec71
+--- /dev/null
++++ b/list.c
+@@ -0,0 +1,159 @@
++#include "list.h"
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++
++list_t *create_list(void) {
++	list_t *list = malloc(sizeof(list_t));
++	if (!list) {
++		return NULL;
++	}
++	list->capacity = 10;
++	list->length = 0;
++	list->items = malloc(sizeof(void*) * list->capacity);
++	return list;
++}
++
++static void list_resize(list_t *list) {
++	if (list->length == list->capacity) {
++		list->capacity *= 2;
++		list->items = realloc(list->items, sizeof(void*) * list->capacity);
++	}
++}
++
++void list_free(list_t *list) {
++	if (list == NULL) {
++		return;
++	}
++	free(list->items);
++	free(list);
++}
++
++void list_add(list_t *list, void *item) {
++	list_resize(list);
++	list->items[list->length++] = item;
++}
++
++void list_insert(list_t *list, int index, void *item) {
++	list_resize(list);
++	memmove(&list->items[index + 1], &list->items[index], sizeof(void*) * (list->length - index));
++	list->length++;
++	list->items[index] = item;
++}
++
++void list_del(list_t *list, int index) {
++	list->length--;
++	memmove(&list->items[index], &list->items[index + 1], sizeof(void*) * (list->length - index));
++}
++
++void list_cat(list_t *list, list_t *source) {
++	for (int i = 0; i < source->length; ++i) {
++		list_add(list, source->items[i]);
++	}
++}
++
++void list_qsort(list_t *list, int compare(const void *left, const void *right)) {
++	qsort(list->items, list->length, sizeof(void *), compare);
++}
++
++int list_seq_find(list_t *list, int compare(const void *item, const void *data), const void *data) {
++	for (int i = 0; i < list->length; i++) {
++		void *item = list->items[i];
++		if (compare(item, data) == 0) {
++			return i;
++		}
++	}
++	return -1;
++}
++
++int list_find(list_t *list, const void *item) {
++	for (int i = 0; i < list->length; i++) {
++		if (list->items[i] == item) {
++			return i;
++		}
++	}
++	return -1;
++}
++
++void list_swap(list_t *list, int src, int dest) {
++	void *tmp = list->items[src];
++	list->items[src] = list->items[dest];
++	list->items[dest] = tmp;
++}
++
++void list_move_to_end(list_t *list, void *item) {
++	int i;
++	for (i = 0; i < list->length; ++i) {
++		if (list->items[i] == item) {
++			break;
++		}
++	}
++	if (!(i < list->length)) {
++		return;
++	}
++	list_del(list, i);
++	list_add(list, item);
++}
++
++static void list_rotate(list_t *list, int from, int to) {
++	void *tmp = list->items[to];
++
++	while (to > from) {
++		list->items[to] = list->items[to - 1];
++		to--;
++	}
++
++	list->items[from] = tmp;
++}
++
++static void list_inplace_merge(list_t *list, int left, int last, int mid, int compare(const void *a, const void *b)) {
++	int right = mid + 1;
++
++	if (compare(&list->items[mid], &list->items[right]) <= 0) {
++		return;
++	}
++
++	while (left <= mid && right <= last) {
++		if (compare(&list->items[left], &list->items[right]) <= 0) {
++			left++;
++		} else {
++			list_rotate(list, left, right);
++			left++;
++			mid++;
++			right++;
++		}
++	}
++}
++
++static void list_inplace_sort(list_t *list, int first, int last, int compare(const void *a, const void *b)) {
++	if (first >= last) {
++		return;
++	} else if ((last - first) == 1) {
++		if (compare(&list->items[first], &list->items[last]) > 0) {
++			list_swap(list, first, last);
++		}
++	} else {
++		int mid = (int)((last + first) / 2);
++		list_inplace_sort(list, first, mid, compare);
++		list_inplace_sort(list, mid + 1, last, compare);
++		list_inplace_merge(list, first, last, mid, compare);
++	}
++}
++
++void list_stable_sort(list_t *list, int compare(const void *a, const void *b)) {
++	if (list->length > 1) {
++		list_inplace_sort(list, 0, list->length - 1, compare);
++	}
++}
++
++void list_free_items_and_destroy(list_t *list) {
++	if (!list) {
++		return;
++	}
++
++	for (int i = 0; i < list->length; ++i) {
++		free(list->items[i]);
++	}
++	list_free(list);
++}
++
+diff --git a/list.h b/list.h
+new file mode 100644
+index 0000000..895f6cc
+--- /dev/null
++++ b/list.h
+@@ -0,0 +1,35 @@
++#ifndef _SWAY_LIST_H
++#define _SWAY_LIST_H
++
++typedef struct {
++	int capacity;
++	int length;
++	void **items;
++} list_t;
++
++list_t *create_list(void);
++void list_free(list_t *list);
++void list_add(list_t *list, void *item);
++void list_insert(list_t *list, int index, void *item);
++void list_del(list_t *list, int index);
++void list_cat(list_t *list, list_t *source);
++// See qsort. Remember to use *_qsort functions as compare functions,
++// because they dereference the left and right arguments first!
++void list_qsort(list_t *list, int compare(const void *left, const void *right));
++// Return index for first item in list that returns 0 for given compare
++// function or -1 if none matches.
++int list_seq_find(list_t *list, int compare(const void *item, const void *cmp_to), const void *cmp_to);
++int list_find(list_t *list, const void *item);
++// stable sort since qsort is not guaranteed to be stable
++void list_stable_sort(list_t *list, int compare(const void *a, const void *b));
++// swap two elements in a list
++void list_swap(list_t *list, int src, int dest);
++// move item to end of list
++void list_move_to_end(list_t *list, void *item);
++
++/* Calls `free` for each item in the list, then frees the list.
++ * Do not use this to free lists of primitives or items that require more
++ * complicated deallocation code.
++ */
++void list_free_items_and_destroy(list_t *list);
++#endif
+diff --git a/stringop.c b/stringop.c
+new file mode 100644
+index 0000000..23c4b96
+--- /dev/null
++++ b/stringop.c
+@@ -0,0 +1,331 @@
++#define _POSIX_C_SOURCE 200809L
++#include <ctype.h>
++#include <stdbool.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <strings.h>
++#include <wordexp.h>
++#include <wordexp.h>
++#include "list.h"
++
++static const char whitespace[] = " \f\n\r\t\v";
++
++void strip_whitespace(char *str) {
++	size_t len = strlen(str);
++	size_t start = strspn(str, whitespace);
++	memmove(str, &str[start], len + 1 - start);
++
++	if (*str) {
++		for (len -= start + 1; isspace(str[len]); --len) {}
++		str[len + 1] = '\0';
++	}
++}
++
++void strip_quotes(char *str) {
++	bool in_str = false;
++	bool in_chr = false;
++	bool escaped = false;
++	char *end = strchr(str,0);
++	while (*str) {
++		if (*str == '\'' && !in_str && !escaped) {
++			in_chr = !in_chr;
++			goto shift_over;
++		} else if (*str == '\"' && !in_chr && !escaped) {
++			in_str = !in_str;
++			goto shift_over;
++		} else if (*str == '\\') {
++			escaped = !escaped;
++			++str;
++			continue;
++		}
++		escaped = false;
++		++str;
++		continue;
++		shift_over:
++		memmove(str, str+1, end-- - str);
++	}
++	*end = '\0';
++}
++
++char *lenient_strcat(char *dest, const char *src) {
++	if (dest && src) {
++		return strcat(dest, src);
++	}
++	return dest;
++}
++
++char *lenient_strncat(char *dest, const char *src, size_t len) {
++	if (dest && src) {
++		return strncat(dest, src, len);
++	}
++	return dest;
++}
++
++// strcmp that also handles null pointers.
++int lenient_strcmp(const char *a, const char *b) {
++	if (a == b) {
++		return 0;
++	} else if (!a) {
++		return -1;
++	} else if (!b) {
++		return 1;
++	} else {
++		return strcmp(a, b);
++	}
++}
++
++list_t *split_string(const char *str, const char *delims) {
++	list_t *res = create_list();
++	char *copy = strdup(str);
++
++	char *token = strtok(copy, delims);
++	while (token) {
++		list_add(res, strdup(token));
++		token = strtok(NULL, delims);
++	}
++	free(copy);
++	return res;
++}
++
++char **split_args(const char *start, int *argc) {
++	int alloc = 2;
++	char **argv = malloc(sizeof(char *) * alloc);
++	bool in_token = false;
++	bool in_string = false;
++	bool in_char = false;
++	bool in_brackets = false; // brackets are used for criteria
++	bool escaped = false;
++	const char *end = start;
++	*argc = 0;
++	if (start) {
++		while (*start) {
++			if (!in_token) {
++				start = (end += strspn(end, whitespace));
++				in_token = true;
++			}
++			if (*end == '"' && !in_char && !escaped) {
++				in_string = !in_string;
++			} else if (*end == '\'' && !in_string && !escaped) {
++				in_char = !in_char;
++			} else if (*end == '[' && !in_string && !in_char && !in_brackets && !escaped) {
++				in_brackets = true;
++			} else if (*end == ']' && !in_string && !in_char && in_brackets && !escaped) {
++				in_brackets = false;
++			} else if (*end == '\\') {
++				escaped = !escaped;
++			} else if (*end == '\0' || (!in_string && !in_char && !in_brackets
++						&& !escaped && strchr(whitespace, *end))) {
++				goto add_token;
++			}
++			if (*end != '\\') {
++				escaped = false;
++			}
++			++end;
++			continue;
++			add_token:
++			if (end - start > 0) {
++				char *token = malloc(end - start + 1);
++				strncpy(token, start, end - start + 1);
++				token[end - start] = '\0';
++				argv[*argc] = token;
++				if (++*argc + 1 == alloc) {
++					argv = realloc(argv, (alloc *= 2) * sizeof(char *));
++				}
++			}
++			in_token = false;
++			escaped = false;
++		}
++	}
++	argv[*argc] = NULL;
++	return argv;
++}
++
++void free_argv(int argc, char **argv) {
++	while (argc-- > 0) {
++		free(argv[argc]);
++	}
++	free(argv);
++}
++
++int unescape_string(char *string) {
++	/* TODO: More C string escapes */
++	int len = strlen(string);
++	int shift = 0;
++	int i;
++	for (i = 0; string[i]; ++i) {
++		if (string[i] == '\\') {
++			switch (string[++i]) {
++			case '0':
++				string[i - 1] = '\0';
++				return i - 1;
++			case 'a':
++				string[i - 1] = '\a';
++				string[i] = '\0';
++				break;
++			case 'b':
++				string[i - 1] = '\b';
++				string[i] = '\0';
++				break;
++			case 'f':
++				string[i - 1] = '\f';
++				string[i] = '\0';
++				break;
++			case 'n':
++				string[i - 1] = '\n';
++				string[i] = '\0';
++				break;
++			case 'r':
++				string[i - 1] = '\r';
++				string[i] = '\0';
++				break;
++			case 't':
++				string[i - 1] = '\t';
++				string[i] = '\0';
++				break;
++			case 'v':
++				string[i - 1] = '\v';
++				string[i] = '\0';
++				break;
++			case '\\':
++				string[i] = '\0';
++				break;
++			case '\'':
++				string[i - 1] = '\'';
++				string[i] = '\0';
++				break;
++			case '\"':
++				string[i - 1] = '\"';
++				string[i] = '\0';
++				break;
++			case '?':
++				string[i - 1] = '?';
++				string[i] = '\0';
++				break;
++			case 'x':
++				{
++					unsigned char c = 0;
++					if (string[i+1] >= '0' && string[i+1] <= '9') {
++						c = string[i+1] - '0';
++						if (string[i+2] >= '0' && string[i+2] <= '9') {
++							c *= 0x10;
++							c += string[i+2] - '0';
++							string[i+2] = '\0';
++						}
++						string[i+1] = '\0';
++					}
++					string[i] = '\0';
++					string[i - 1] = c;
++				}
++			}
++		}
++	}
++	// Shift characters over nullspaces
++	for (i = 0; i < len; ++i) {
++		if (string[i] == 0) {
++			shift++;
++			continue;
++		}
++		string[i-shift] = string[i];
++	}
++	string[len - shift] = 0;
++	return len - shift;
++}
++
++char *join_args(char **argv, int argc) {
++	int len = 0, i;
++	char *res;
++	if (argc < 0) {
++		return NULL;
++	}
++	for (i = 0; i < argc; ++i) {
++		len += strlen(argv[i]) + 1;
++	}
++	res = malloc(len);
++	len = 0;
++	for (i = 0; i < argc; ++i) {
++		strcpy(res + len, argv[i]);
++		len += strlen(argv[i]);
++		res[len++] = ' ';
++	}
++	res[len - 1] = '\0';
++	return res;
++}
++
++static inline char *argsep_next_interesting(const char *src, const char *delim) {
++	char *special = strpbrk(src, "\"'\\");
++	char *next_delim = strpbrk(src, delim);
++	if (!special) {
++		return next_delim;
++	}
++	if (!next_delim) {
++		return special;
++	}
++	return (next_delim < special) ? next_delim : special;
++}
++
++char *argsep(char **stringp, const char *delim, char *matched) {
++	char *start = *stringp;
++	char *end = start;
++	bool in_string = false;
++	bool in_char = false;
++	bool escaped = false;
++	char *interesting = NULL;
++
++	while ((interesting = argsep_next_interesting(end, delim))) {
++		if (escaped && interesting != end) {
++			escaped = false;
++		}
++		if (*interesting == '"' && !in_char && !escaped) {
++			in_string = !in_string;
++			end = interesting + 1;
++		} else if (*interesting == '\'' && !in_string && !escaped) {
++			in_char = !in_char;
++			end = interesting + 1;
++		} else if (*interesting == '\\') {
++			escaped = !escaped;
++			end = interesting + 1;
++		} else if (!in_string && !in_char && !escaped) {
++			// We must have matched a separator
++			end = interesting;
++			if (matched) {
++				*matched = *end;
++			}
++			if (end - start) {
++				*(end++) = 0;
++				*stringp = end;
++				break;
++			} else {
++				end = ++start;
++			}
++		} else {
++			end++;
++		}
++	}
++	if (!interesting) {
++		*stringp = NULL;
++		if (matched) {
++			*matched = '\0';
++		}
++	}
++	return start;
++}
++
++bool expand_path(char **path) {
++	char *ptr;
++	wordexp_t p = {0};
++	while (strstr(*path, "  ")) {
++		*path = realloc(*path, strlen(*path) + 2);
++		ptr = strstr(*path, "  ") + 1;
++		memmove(ptr + 1, ptr, strlen(ptr) + 1);
++		*ptr = '\\';
++	}
++	if (wordexp(*path, &p, 0) != 0 || p.we_wordv[0] == NULL) {
++		wordfree(&p);
++		return false;
++	}
++	free(*path);
++	*path = join_args(p.we_wordv, p.we_wordc);
++	wordfree(&p);
++	return true;
++}
+diff --git a/stringop.h b/stringop.h
+new file mode 100644
+index 0000000..4ca950d
+--- /dev/null
++++ b/stringop.h
+@@ -0,0 +1,30 @@
++#ifndef _SWAY_STRINGOP_H
++#define _SWAY_STRINGOP_H
++
++void strip_whitespace(char *str);
++void strip_quotes(char *str);
++
++// strcat that does nothing if dest or src is NULL
++char *lenient_strcat(char *dest, const char *src);
++char *lenient_strncat(char *dest, const char *src, size_t len);
++
++// strcmp that also handles null pointers.
++int lenient_strcmp(const char *a, const char *b);
++
++// Simply split a string with delims, free with `list_free_items_and_destroy`
++list_t *split_string(const char *str, const char *delims);
++
++// Splits an argument string, keeping quotes intact
++char **split_args(const char *str, int *argc);
++void free_argv(int argc, char **argv);
++
++int unescape_string(char *string);
++char *join_args(char **argv, int argc);
++
++// Split string into 2 by delim, handle quotes
++char *argsep(char **stringp, const char *delim, char *matched_delim);
++
++// Expand a path using shell replacements such as $HOME and ~
++bool expand_path(char **path);
++
++#endif
+-- 
+2.36.1
+
diff --git a/config.mk b/config.mk
index 330b564d..ba24bb80 100644
--- a/config.mk
+++ b/config.mk
@@ -6,7 +6,6 @@ PREFIX = /usr/local
 MANDIR = $(PREFIX)/share/man
 
 # Compile flags that can be used
-CFLAGS = -Ofast -march=native -flto
 #CFLAGS = -pedantic -Wall -Wextra -Werror -Wno-unused-parameter -Wno-sign-compare -Wno-unused-function -Wno-unused-variable -Wno-unused-result -Wdeclaration-after-statement
 
 XWAYLAND =
